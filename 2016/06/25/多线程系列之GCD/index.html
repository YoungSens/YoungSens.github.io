<!doctype html>



  


<html class="theme-next muse use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="iOS,Swift,多线程,GCD," />





  <link rel="alternate" href="/atom.xml" title="ySenIn's Blog" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta name="description" content="前言网上关于多线程的文章已经烂大街了，问题是为啥我还要继续写呢？没有为啥，单纯想写。看到有些文章空泛的描述出使用的什么方法来生成多线程，然后就扔一堆代码，这种做法真是令人作呕，至少我是这么觉得的。好吧，调侃的差不多了，也来写写自己对于多线程的理解，那么这一片会首先介绍GCD。文章主要参考[Objective-C高级编程、iOS与OS X多线程和内存指南]，一本很不错的书。算了还是不要说参考了，摘抄">
<meta property="og:type" content="article">
<meta property="og:title" content="多线程系列之GCD之一">
<meta property="og:url" content="http://yoursite.com/2016/06/25/多线程系列之GCD/index.html">
<meta property="og:site_name" content="ySenIn's Blog">
<meta property="og:description" content="前言网上关于多线程的文章已经烂大街了，问题是为啥我还要继续写呢？没有为啥，单纯想写。看到有些文章空泛的描述出使用的什么方法来生成多线程，然后就扔一堆代码，这种做法真是令人作呕，至少我是这么觉得的。好吧，调侃的差不多了，也来写写自己对于多线程的理解，那么这一片会首先介绍GCD。文章主要参考[Objective-C高级编程、iOS与OS X多线程和内存指南]，一本很不错的书。算了还是不要说参考了，摘抄">
<meta property="og:updated_time" content="2016-07-01T07:37:04.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="多线程系列之GCD之一">
<meta name="twitter:description" content="前言网上关于多线程的文章已经烂大街了，问题是为啥我还要继续写呢？没有为啥，单纯想写。看到有些文章空泛的描述出使用的什么方法来生成多线程，然后就扔一堆代码，这种做法真是令人作呕，至少我是这么觉得的。好吧，调侃的差不多了，也来写写自己对于多线程的理解，那么这一片会首先介绍GCD。文章主要参考[Objective-C高级编程、iOS与OS X多线程和内存指南]，一本很不错的书。算了还是不要说参考了，摘抄">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>

  <title> 多线程系列之GCD之一 | ySenIn's Blog </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">ySenIn's Blog</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">ySen</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-guestbook">
          <a href="/guestbook" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            留言
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                多线程系列之GCD之一
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-06-25T16:45:34+08:00" content="2016-06-25">
              2016-06-25
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/多线程/" itemprop="url" rel="index">
                    <span itemprop="name">多线程</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/06/25/多线程系列之GCD/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/06/25/多线程系列之GCD/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>网上关于多线程的文章已经烂大街了，问题是为啥我还要继续写呢？没有为啥，单纯想写。看到有些文章空泛的描述出使用的什么方法来生成多线程，然后就扔一堆代码，这种做法真是令人作呕，至少我是这么觉得的。好吧，调侃的差不多了，也来写写自己对于多线程的理解，那么这一片会首先介绍GCD。文章主要参考[Objective-C高级编程、iOS与OS X多线程和内存指南]，一本很不错的书。算了还是不要说参考了，摘抄。</p>
<blockquote>
<p>示例代码语言：Swift 2.2<br>Xcode版本: Xcode 7.3</p>
</blockquote>
<p>那么首先说，什么是GCD呢？按照苹果的官方解释说：GCD(Grand Central Dispatch)是异步执行技术的技术之一。一般将应用程序中技术的线程管理用的代码在系统中实现。开发者只需要定义想执行的任务追加到适当的Dispatch Queue中，GCD生成必要的线程并计划执行任务。由于线程管理是作为系统的一部分来实现的，因此可统一管理，也可执行任务，这样就比之前的线程更有效率（摘自上面提到的参考书，参考书又参考值苹果官方文档，现在沦为文字的搬运工了，呵呵哒）。<br>简单的来讲，就是说我们GCD的API，然后将我们需要执行的处理写在block中，然后把block追加到GCD的队列就可以了，GCD会自己去规划并生成线程进行处理。</p>
<h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p>按照wikipedia中的描述是：线程是操作系统能够进行运算调度的最小单位，它被包含在进程中……线程分为两种，同步与非同步（异步）。同步是在本线程中执行，异步则是开辟新的线程执行。在项目中，适当的使用两者会让整个项目的性能得到很大的提升。虽然在使用多线程时，会遇到很多问题，学会处理多线程带来的问题，及时避免就不会出现太大的问题。</p>
<h4 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h4><p>针对于同步线程来讲，在添加任务到同步线程队列中，只有等前一个任务完成之后，后一个任务才能继续执行。大概意思和队列是一样的，先进先出的原则，正如一条单行线。代码如下：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">"同步线程执行开始"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> queue = dispatch_queue_create(<span class="string">"com.ysenin.symultiplethread"</span>, <span class="literal">nil</span>)</span><br><span class="line">dispatch_sync(queue) &#123; </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"同步线程执行中"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"同步线程执行完毕"</span>)</span><br></pre></td></tr></table></figure></p>
<p>上面这段代码呢，执行结果为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">同步线程执行开始</span><br><span class="line">同步线程执行中</span><br><span class="line">同步线程执行完毕</span><br></pre></td></tr></table></figure></p>
<p><strong>注意</strong>此时需要注意很重要的一点，真的很重要的一点。如果把上面的queue换成dispatch_get_main_queue()呢？这个又会怎样呢？结果只会输出：“同步线程执行开始”。这是为什么呢？如下：</p>
<blockquote>
<p><strong>死锁</strong><br>在调用dispatch_sync(queue)时，需要将线程阻塞，此时是主线程；<br>同步派发sync导致block需要在主线程中执行结束后才会返回；<br>而此时主线程被阻塞，两者相互等待，线程出现死锁。</p>
</blockquote>
<p>同样，Serial Dispatch Queue中，也会出现类似的情况，代码如下：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">"线程执行开始"</span>)</span><br><span class="line">queue = dispatch_queue_create(<span class="string">"com.ysenin.symultiplethread"</span>, <span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..&lt;<span class="number">1000</span> &#123;</span><br><span class="line">    dispatch_async(queue, &#123; </span><br><span class="line">        dispatch_sync(queue, &#123; </span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"线程执行中: <span class="subst">\(i)</span>"</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"线程执行完毕"</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>代码执行的结果为:”线程执行开始”,当然此时代码页面不会阻塞主线程，而仅仅是queue中的派发的线程会阻塞。至于什么事Serial Dispatch Queue，在接下来的部分会讲到。所以，如果在主线程派发队列或者Serial Dispatch Queue中就需要避免上面出现的问题，否则代码写完半天，不出结果，那就比较恶心了。</p>
<h4 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h4><p>上面简单的讲了同步，接下来讲讲异步。异步在我们项目中可是经常遇到的问题，譬如网络数据加载，动画的长时间绘制和大文件处理等。由于我们现在所用到的设备大部分已经不是单核设备，都已经升级为多核，那么对于多核来讲，意味着线程变多，处理变快。随着线程变的多，也就出现了不同的问题。在使用多线程过程中，容易出现一下问题：</p>
<blockquote>
<p>1.数据竞争（两个或者多个线程，更新同一条数据）<br>2.死锁（两个线程相互指向对方）<br>3.大量线程导师消耗大量内存（大量开辟线程）</p>
</blockquote>
<p>当然，解决上述问题的方法会很多，虽然有点难，比起出现的概率和性能的提升，这点难点都不足以阻碍使用GCD。</p>
<p>异步的源代码如下所示：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dispatch_async(queue, &#123; </span><br><span class="line">    <span class="comment">// 想要执行的任务</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>异步执行处理包涵两种队列: Serial Dispatch Queue、Concurrent Dispatch Queue。<br>| Dispatch Queue的种类       | 说明                 |<br>|—————————|———————|<br>| Serial Dispatch Queue     | 等待现在执行中处理结束  |<br>| Concurrent Dispatch Queue | 不等待现在执行中处理结束 |</p>
<p>什么意思呢？举个例子，我们去银行办理业务的时候，通常都会拿号，针对不同的业务，我们可以拿不同形式的号，譬如VIP业务和普通的业务。由于VIP业务不是人人都需要，通常只保留一个通道，相反，普通业务办理的人数会很多，那就需要很多通道。对于办理VIP业务的人来讲，只有等号数在自己前面的人办理完毕后，自己才能去办理自己的业务，这就是我们所说的Serial Dispatch Queue。而办理普通业务的人呢？只要前面通道空闲了，后面的人就可以有序的去办理自己的业务，Concurrent Dispatch Queue也就对应这种场景了。</p>
<h5 id="dispatch-queue-create创建"><a href="#dispatch-queue-create创建" class="headerlink" title="dispatch_queue_create创建"></a>dispatch_queue_create创建</h5><p>上面讲的两种队列创建，可以利用dispatch_queue_create来创建：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Serial Dispatch Queue</span></span><br><span class="line"><span class="keyword">let</span> queue = dispatch_queue_create(<span class="string">"com.ysenin.multiplethread"</span>, <span class="type">DISPATCH_QUEUE_SERIAL</span>)</span><br><span class="line"><span class="keyword">let</span> queue = dispatch_queue_create(<span class="string">"com.ysenin.multiplethread"</span>, <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Concurrent Dispatch Queue</span></span><br><span class="line"><span class="keyword">let</span> queue = dispatch_queue_create(<span class="string">"com.ysenin.multiplethread"</span>, <span class="type">DISPATCH_QUEUE_CONCURRENT</span>)</span><br></pre></td></tr></table></figure></p>
<p>通过上面的代码我们可以看到，dispatch_queue_create含有两个参数：第一个是队列名称，第二个是类型。对于队列名，苹果官方的描述如下：</p>
<blockquote>
<p>A string label to attach to the queue to uniquely identify it in debugging tools such as Instruments…</p>
</blockquote>
<p>意思是说，这个名字仅仅是在你调试的时候知道是哪个线程而已。那么不同对象产生的相同名字的队列，它就是两个区分开的队列。针对这个问题，也是让我思考了很久，然后在<a href="http://stackoverflow.com/questions/19421283/do-2-objects-creating-serial-queues-with-the-same-name-share-the-same-queue" target="_blank" rel="external">stackoverflow</a>中找到答案了。</p>
<p>对于Serial Dispatch Queue，我们看到有两种dispatch_queue_create创建方法，第二个参数可以默认为nil，也可以添加DISPATCH_QUEUE_SERIAL来标识。对于Serial Dispatch Queue，我们可以生成多个，多个队列将并行执行。什么意思呢，还是拿银行的VIP业务例子来说明吧。在同一个地区，有同一个银行的不同的分行，每个分行都有VIP通道，这些通道互不影响，并行处理自己的业务。问题在于，如果一个地区如果有成千上万个分行，但事实上只有10个分行有人办理VIP业务，其他银行也就相当于浪费了。这就是前面提到的大量的生成线程，消耗大量的内存，引起大量的上下文切换，造成不必要浪费。因为，在实际编程中，我们需要避免这类似的情况发生。</p>
<p>那么使用Serial Dispatch Queue也不是没有好处，因为在多线程更新数据的情况下，我们可能遇到多个线程更新到同一个数据。那么Serial Dispatch Queue就很好的避免了这个情况。也不是说完全避免，只是在绝大部分情况下，出现数据竞争的机率变小了。</p>
<blockquote>
<p><strong>说明</strong><br>在iOS 6.0和OS X10.8的版本，已经引入ARC，因此不需要自己去管理内存。</p>
</blockquote>
<p>Serial Dispatch Queue样例代码:<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> queue = dispatch_queue_create(<span class="string">"com.ysenin.multiplethread"</span>, <span class="type">DISPATCH_QUEUE_SERIAL</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..&lt;<span class="number">1000</span> &#123;</span><br><span class="line">    dispatch_async(queue, &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"block: <span class="subst">\(i)</span>"</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Sample Output</span></span><br><span class="line">block: <span class="number">0</span></span><br><span class="line">block: <span class="number">1</span></span><br><span class="line">block: <span class="number">2</span></span><br><span class="line">block: <span class="number">3</span></span><br><span class="line">block: <span class="number">4</span></span><br><span class="line">block: <span class="number">5</span></span><br><span class="line">block: <span class="number">6</span></span><br><span class="line">block: <span class="number">7</span></span><br><span class="line">block: <span class="number">8</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<p>Concurrent Dispatch Queue样例代码:<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> queue = dispatch_queue_create(<span class="string">"com.ysenin.multiplethread"</span>, <span class="type">DISPATCH_QUEUE_CONCURRENT</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..&lt;<span class="number">1000</span> &#123;</span><br><span class="line">    dispatch_async(queue, &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"block: <span class="subst">\(i)</span>"</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Sample Output</span></span><br><span class="line">block: <span class="number">2</span></span><br><span class="line">block: <span class="number">3</span></span><br><span class="line">block: <span class="number">1</span></span><br><span class="line">block: <span class="number">4</span></span><br><span class="line">block: <span class="number">0</span></span><br><span class="line">block: <span class="number">6</span></span><br><span class="line">block: <span class="number">5</span></span><br><span class="line">block: <span class="number">7</span></span><br><span class="line">block: <span class="number">8</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<p>针对于具有相同名称的Serial Dispatch Queue生成的多个queue源码示例如下：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> queue = dispatch_queue_create(<span class="string">"com.ysenin.multiplethread"</span>, <span class="type">DISPATCH_QUEUE_SERIAL</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..&lt;<span class="number">10</span> &#123;</span><br><span class="line">    dispatch_async(queue, &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"block: <span class="subst">\(i)</span>"</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">queue = dispatch_queue_create(<span class="string">"com.ysenin.multiplethread"</span>, <span class="type">DISPATCH_QUEUE_SERIAL</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..&lt;<span class="number">10</span> &#123;</span><br><span class="line">    dispatch_async(queue, &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"block123: <span class="subst">\(i)</span>"</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Sample Output</span></span><br><span class="line">block: <span class="number">0</span></span><br><span class="line">block123: <span class="number">0</span></span><br><span class="line">block: <span class="number">1</span></span><br><span class="line">block123: <span class="number">1</span></span><br><span class="line">block: <span class="number">2</span></span><br><span class="line">block123: <span class="number">2</span></span><br><span class="line">block: <span class="number">3</span></span><br><span class="line">block123: <span class="number">3</span></span><br><span class="line">block: <span class="number">4</span></span><br><span class="line">block123: <span class="number">4</span></span><br><span class="line">block: <span class="number">5</span></span><br><span class="line">block123: <span class="number">5</span></span><br><span class="line">block: <span class="number">6</span></span><br><span class="line">block123: <span class="number">6</span></span><br><span class="line">block: <span class="number">7</span></span><br><span class="line">block123: <span class="number">7</span></span><br><span class="line">block: <span class="number">8</span></span><br><span class="line">block123: <span class="number">8</span></span><br><span class="line">block: <span class="number">9</span></span><br><span class="line">block123: <span class="number">9</span></span><br></pre></td></tr></table></figure></p>
<h5 id="Global-Dispatch-Queue创建"><a href="#Global-Dispatch-Queue创建" class="headerlink" title="Global Dispatch Queue创建"></a>Global Dispatch Queue创建</h5><p>这个是获取系统标准提供的Dispatch Queue。也即是说，我们可以不需要像上一节提供的那样自己创建Dispatch Queue,系统自己会给我们提供几个Dispatch Queue使用，分别是：Main Dispatch Queue和Global Dispatch Queue。</p>
<p><strong>Main Dispatch Queue顾名思义就是主线程中执行的Dispatch Queue，因为主线程只有1个，所以Main Dispatch Queue也就是Serial Dispatch Queue。另外一个Global Dispatch Queue是所有应用程序都能使用的Concurrent Dispatch Queue。</strong></p>
<p>Global Dispatch Queue有4个优先级，分别是High Priority(最高优先级)、 Default Priority(默认优先级)、 Low Priority(低优先级)、 Background Priority(后台优先级)。通过XNU内核管理用于Global Dispatch Queue的线程，将各自使用的Global Dispatch Queue的执行优先级作为线程执行的优先级。在Global Dispatch Queue追加处理时，应该选择与处理内容对应的执行优先级的Global Dispatch Queue。</p>
<blockquote>
<p>注意：XUN内核用语Global Dispatch Queue的线程并不能保证实时性，因此优先级之时大致的判断。</p>
</blockquote>
<p>关于Global Dispatch Queue获取和使用的源代码如下：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> mainQueue = dispatch_get_main_queue() <span class="comment">// Main Dispatch Queue的获取方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line">  * Global Dispatch Queue获取</span><br><span class="line">  * DISPATCH_QUEUE_PRIORITY_HIGH       -- 最高优先级</span><br><span class="line">  * DISPATCH_QUEUE_PRIORITY_DEFAULT    -- 默认优先级</span><br><span class="line">  * DISPATCH_QUEUE_PRIORITY_LOW        -- 低优先级</span><br><span class="line">  * DISPATCH_QUEUE_PRIORITY_BACKGROUND -- 后台优先级</span><br><span class="line">  */</span></span><br><span class="line"><span class="comment">// 其他按照上面给出来的名称，改变参数就可以了</span></span><br><span class="line"><span class="keyword">let</span> queue = dispatch_get_global_queue(<span class="type">DISPATCH_QUEUE_PRIORITY_HIGH</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">dispatch_async(queue, ^&#123;</span><br><span class="line">    <span class="comment">// 可执行的处理</span></span><br><span class="line"></span><br><span class="line">    dispatch_async(mainQueue, ^&#123;</span><br><span class="line">        <span class="comment">// 主线程中的处理</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<h5 id="dispatch-set-target-queue"><a href="#dispatch-set-target-queue" class="headerlink" title="dispatch_set_target_queue"></a>dispatch_set_target_queue</h5><p>关于这个函数，有两种功能：1.变更Dispatch Queue的执行优先级；2.作为Dispatch Queue的执行阶层。</p>
<p>第一个功能意思是什么呢？我们看下dispatch_set_target_queue(sourceQueue, goalQueue)。第一个参数为源Dispatch Queue，第二个参数为目标Dispatch Queue。那么结果就是将源Dispatch Queue的优先级设置为目标Dispatch Queue的优先级。</p>
<blockquote>
<p>注: dispatch_queue_create创建的Dispatch Queue，不管是Serial Dispatch Queue还是Concurrent Dispatch Queue，默认优先级都是Global Dispatch Queue中的DISPATCH_QUEUE_PRIORITY_DEFAULT相同的。</p>
</blockquote>
<p>至于第二个功能嘛，很简单，可以理解为，合并几个通过dispatch_queue_create创建的Dispatch Queue为1个Serial Dispatch Queue。当然啦，也可以作为Concurrent Dispatch Queue。但是那不就是合并之前Dispatch Queue嘛。</p>
<blockquote>
<p>注：只能合并dispatch_queue_create创建的Dispatch Queue，不能合并通过Global Dispatch Queue创建，至于为什么嘛，啥时候找找原理，测试是不可以的。</p>
</blockquote>
<p>第二个功能的示例代码如下：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">testTargetQueue</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">let</span> targetQueue = dispatch_queue_create(<span class="string">"target"</span>, <span class="type">DISPATCH_QUEUE_SERIAL</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> queue1 = dispatch_queue_create(<span class="string">"queue1"</span>, <span class="type">DISPATCH_QUEUE_SERIAL</span>)</span><br><span class="line">    <span class="keyword">let</span> queue2 = dispatch_queue_create(<span class="string">"queue2"</span>, <span class="type">DISPATCH_QUEUE_CONCURRENT</span>)</span><br><span class="line">    <span class="keyword">let</span> queue3 = dispatch_get_global_queue(<span class="type">DISPATCH_QUEUE_PRIORITY_DEFAULT</span>, <span class="number">0</span>)</span><br><span class="line">    </span><br><span class="line">    dispatch_set_target_queue(queue1, targetQueue)</span><br><span class="line">    dispatch_set_target_queue(queue2, targetQueue)</span><br><span class="line">    dispatch_set_target_queue(queue3, targetQueue)</span><br><span class="line">    </span><br><span class="line">    dispatch_async(queue1) &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"start queue1"</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="type">NSThread</span>.sleepForTimeInterval(<span class="number">2</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"end queue1"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    dispatch_async(queue2) &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"start queue2"</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="type">NSThread</span>.sleepForTimeInterval(<span class="number">2</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"end queue2"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    dispatch_async(queue3) &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"start queue3"</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="type">NSThread</span>.sleepForTimeInterval(<span class="number">2</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"end queue3"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Sample Output:</span></span><br><span class="line">start queue3</span><br><span class="line">start queue1</span><br><span class="line">end queue3</span><br><span class="line">end queue1</span><br><span class="line">start queue2</span><br><span class="line">end queue2</span><br></pre></td></tr></table></figure></p>
<p>通过上面的样例输出，可以看到Global Dispatch Queue是不能通过dispatch_set_target_queue改变执行阶级的。</p>
<h5 id="dispatch-after"><a href="#dispatch-after" class="headerlink" title="dispatch_after"></a>dispatch_after</h5><p>简单说一下，就是多长时间之后，执行需要的操作。</p>
<blockquote>
<p>dispatch_after(time, queue, block)<br>time: dispatch_time(DISPATCH_TIME_NOW, Int64(3 * NSEC_PER_SEC))<br>          startTime: 起始时间<br>          endTime: 相对的结束时间<br>queue: 在哪个线程队列中执行<br>block: 执行的操作</p>
<p>注：dispatch_after的time，并不是绝对的时间，实际时间决定于该线程所在的runloop的执行时间，例如，runloop每0.01秒执行一次，那就是最快time，最慢响应时间为time + 0.01。</p>
</blockquote>
<h5 id="Dispatch-Group"><a href="#Dispatch-Group" class="headerlink" title="Dispatch Group"></a>Dispatch Group</h5><p>在追加到Dipatch Queue中的多个处理全部结束后，想执行结束操作。如果只使用Serial Dispatch Queue，这需要前者处理完毕之后，后面的才能有序的处理，在时间效率上会比较低下。在这种情况下，使用Dispatch Group，就可以轻松搞定。<br>示例代码如下：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> group = dispatch_group_create()</span><br><span class="line"><span class="keyword">let</span> queue = dispatch_get_global_queue(<span class="type">DISPATCH_QUEUE_PRIORITY_DEFAULT</span>, <span class="number">0</span>)</span><br><span class="line">        </span><br><span class="line">dispatch_group_async(group, queue) &#123; </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"block 1"</span>)</span><br><span class="line">&#125;</span><br><span class="line">dispatch_group_async(group, queue) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"block 2"</span>)</span><br><span class="line">&#125;</span><br><span class="line">dispatch_group_async(group, queue) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"block 3"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dispatch_group_notify(group, dispatch_get_main_queue()) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"done"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Sample Output</span></span><br><span class="line">block <span class="number">1</span></span><br><span class="line">block <span class="number">3</span></span><br><span class="line">block <span class="number">2</span></span><br><span class="line">done</span><br></pre></td></tr></table></figure></p>
<p>当然，在我们执行的group的过程中，我们是可以等待追加的所有处理完毕，之后再进行下一步处理，也可以在我们规定的时间内，进行下一步操作。那么，这就需要用到dispatch_group_wait(group, DISPATCH_TIME_FOREVER)。第一个参数：上面定义的group；第二个参数：定义的执行时间，DISPATCH_TIME_FOREVER即等待所有执行结束，也可以使用dispatch_time定义的等待时间。具体代码如下：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> time = dispatch_time(<span class="type">DISPATCH_TIME_NOW</span>, <span class="number">0</span>)</span><br><span class="line"><span class="keyword">let</span> result = dispatch_group_wait(group, time)</span><br><span class="line"><span class="keyword">if</span> result == <span class="number">0</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Done"</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Not Finish."</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Sample Output:</span></span><br><span class="line"><span class="type">Not</span> <span class="type">Finish</span>.</span><br></pre></td></tr></table></figure></p>
<h5 id="dispatch-barrier-async"><a href="#dispatch-barrier-async" class="headerlink" title="dispatch_barrier_async"></a>dispatch_barrier_async</h5><p>这是个什么函数呢？还是给个场景吧，数据库读写的时候，发现在我们更新到的时候，需要写入数据。那么，在更新前是不需要什么处理的，但更新后的数据想要读出新数据，这该怎么办呢？</p>
<p>上面的问题，我们可以通过Serial Dispatch Queue处理，Serial Dispatch Queue的特性又是单通道，只能串行执行，效率不高。在这种情况下，GCD给我们提供了更加聪明的方法dispatch_barrier_async。配合Concurrent Dispatch Queue使用dispatch_barrier_async处理，会将更新的数据并行执行，处理完成后做dispatch_barrier_async的追加处理，之后再做余下的并行执行。</p>
<p>也就是说，dispatch_barrier_async类似于坐过山车，前面的人怎么排队都好，只有人齐才会发车。只有过山车停，人才可以下来，然后做各自喜欢的事情。那么dispatch_barrier_async就很好的把控了两者之间的关口，达到数据统一。</p>
<p>dispatch_barrier_async(queue, block)，第一个参数为处理的队列，第二个为执行的处理。示例代码如下：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> queue = dispatch_queue_create(<span class="string">"text"</span>, <span class="type">DISPATCH_QUEUE_CONCURRENT</span>)</span><br><span class="line">        </span><br><span class="line">dispatch_async(queue) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"handler start 1"</span>)</span><br><span class="line">    <span class="type">NSThread</span>.sleepForTimeInterval(<span class="number">2</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"handler end 1"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dispatch_async(queue) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"handler start 2"</span>)</span><br><span class="line">    <span class="type">NSThread</span>.sleepForTimeInterval(<span class="number">2</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"handler end 2"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dispatch_async(queue) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"handler start 3"</span>)</span><br><span class="line">    <span class="type">NSThread</span>.sleepForTimeInterval(<span class="number">2</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"handler end 3"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dispatch_barrier_async(queue) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"barrier handler start"</span>)</span><br><span class="line">    <span class="type">NSThread</span>.sleepForTimeInterval(<span class="number">2</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"barrier handler end"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dispatch_async(queue) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"handler start 4"</span>)</span><br><span class="line">    <span class="type">NSThread</span>.sleepForTimeInterval(<span class="number">2</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"handler end 4"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dispatch_async(queue) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"handler start 5"</span>)</span><br><span class="line">    <span class="type">NSThread</span>.sleepForTimeInterval(<span class="number">2</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"handler end 5"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dispatch_async(queue) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"handler start 6"</span>)</span><br><span class="line">    <span class="type">NSThread</span>.sleepForTimeInterval(<span class="number">2</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"handler end 6"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Sample Output</span></span><br><span class="line">handler start <span class="number">1</span></span><br><span class="line">handler start <span class="number">3</span></span><br><span class="line">handler start <span class="number">2</span></span><br><span class="line">handler end <span class="number">3</span></span><br><span class="line">handler end <span class="number">1</span></span><br><span class="line">handler end <span class="number">2</span></span><br><span class="line">barrier handler start</span><br><span class="line">barrier handler end</span><br><span class="line">handler start <span class="number">4</span></span><br><span class="line">handler start <span class="number">5</span></span><br><span class="line">handler start <span class="number">6</span></span><br><span class="line">handler end <span class="number">5</span></span><br><span class="line">handler end <span class="number">4</span></span><br><span class="line">handler end <span class="number">6</span></span><br></pre></td></tr></table></figure></p>
<p>值得注意一点的就是：我们生成的Dispatch Queue必须是通过dispatch_queue_create生成的Concurrent Dispatch Queu，否则无效，即使Global Dispatch Queue在一定意义上也是Concurrent Dispatch Queu。</p>
<h5 id="dispatch-apply"><a href="#dispatch-apply" class="headerlink" title="dispatch_apply"></a>dispatch_apply</h5><p>dispatch_apple函数时dispatch_sync函数和Dispatch Group的关联API，高函数制定的次数将指定的block追加到Dispatch Queue中，并等待结束。开示例代码吧，这个容易懂：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> queue = dispatch_get_global_queue(<span class="type">DISPATCH_QUEUE_PRIORITY_DEFAULT</span>, <span class="number">0</span>)</span><br><span class="line"><span class="keyword">let</span> array: [<span class="type">Int</span>] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>]</span><br><span class="line"></span><br><span class="line">dispatch_apply(array.<span class="built_in">count</span>, queue) &#123; (index: <span class="type">Int</span>) <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(array[index])</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"done"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Sample Output</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line">done</span><br></pre></td></tr></table></figure></p>
<p>dispatch_apply(count, queue, block(index: Int))，第一个参数为执行几次，第二个参数为执行的队列，第三个参数为执行的第index个block。通过示例代码我们会发现，在dispatch_apply内部的block是异步执行的，但只有执行完count次之后，才会结束。也就是说，dispatch_apply是同步的，但在内部的count次block执行，确实异步的。<br>因此，在实际处理过程中，将dispatch_apply写在异步执行代码块中。</p>
<h5 id="dispatch-suspend-dispatch-resume"><a href="#dispatch-suspend-dispatch-resume" class="headerlink" title="dispatch_suspend/dispatch_resume"></a>dispatch_suspend/dispatch_resume</h5><p>dispatch_suspend(queue): 将queue挂起，即放到阻塞线程中，等待激活。<br>dispatch_resume(queue): 恢复queue，从阻塞状态变为就绪状态，等到执行。</p>
<h5 id="dispatch-once"><a href="#dispatch-once" class="headerlink" title="dispatch_once"></a>dispatch_once</h5><p>dispatch_once保证在应用程序中只执行一次处理，主要解决在多线程环境下，保证安全。常用于单例模式，生成单例对象时使用。<br>示例代码：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">var</span> <span class="title">shareInstance</span>: <span class="title">SYObjectClass</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Static</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">var</span> onceToken: dispatch_once_t = <span class="number">0</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">var</span> instance: <span class="type">SYObjectClass</span>?</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    dispatch_once(&amp;<span class="type">Static</span>.onceToken) &#123; </span><br><span class="line">        <span class="type">Static</span>.instance = <span class="type">SYObjectClass</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="type">Static</span>.instance!</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>花了几天时间，把GCD看了下，以前没怎么仔细花功夫看过，因此这次所花的时间还是值得的，把之前关于GCD比较纳闷的问题解决了一下。GCD是纯C语言的API；处理同步数据的时候非常高效，不需要添加同步锁；使用GCD的dispatch_once也可以保证在多线程中之生成一个对象等。至于和几种方式的区别，会在接下来几篇关于多线程处理方法写完之后做一个总结。不管怎样，只有在项目中在适当的地方，添加合适的多线程处理方式，才能让项目变得更加好。</p>
<h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><p>1.[Objective-C高级编程 iOS与OS X多线程和内存指南]<br>2.[Effective Objective-C 2.0编写高质量iOS和OS X代码的52个有效方法]<br>3.<a href="http://www.infoq.com/cn/articles/os-x-ios-multithread-technology" target="_blank" rel="external">OS X 和 iOS 中的多线程技术</a><br>4.<a href="https://www.zybuluo.com/MicroCai/note/64272" target="_blank" rel="external">Effective Objective-C Notes：GCD 实现同步锁</a></p>

      
    </div>

    <div>
      
        
      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/iOS/" rel="tag">#iOS</a>
          
            <a href="/tags/Swift/" rel="tag">#Swift</a>
          
            <a href="/tags/多线程/" rel="tag">#多线程</a>
          
            <a href="/tags/GCD/" rel="tag">#GCD</a>
          
        </div>
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2016/06/22/iOS利用Runtime机制添加额外的属性/" rel="next" title="iOS在分类(Category)中添加并使用属性">
                <i class="fa fa-chevron-left"></i> iOS在分类(Category)中添加并使用属性
              </a>
            
          </div>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2016/06/29/简历-杨森-iOS开发工程师/" rel="prev" title="简历.杨森.iOS开发工程师">
                简历.杨森.iOS开发工程师 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
        <div class="ds-share flat" data-thread-key="2016/06/25/多线程系列之GCD/"
     data-title="多线程系列之GCD之一"
     data-content=""
     data-url="http://yoursite.com/2016/06/25/多线程系列之GCD/">
  <div class="ds-share-inline">
    <ul  class="ds-share-icons-16">

      <li data-toggle="ds-share-icons-more"><a class="ds-more" href="javascript:void(0);">分享到：</a></li>
      <li><a class="ds-weibo" href="javascript:void(0);" data-service="weibo">微博</a></li>
      <li><a class="ds-qzone" href="javascript:void(0);" data-service="qzone">QQ空间</a></li>
      <li><a class="ds-qqt" href="javascript:void(0);" data-service="qqt">腾讯微博</a></li>
      <li><a class="ds-wechat" href="javascript:void(0);" data-service="wechat">微信</a></li>

    </ul>
    <div class="ds-share-icons-more">
    </div>
  </div>
</div>
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
      <div class="ds-thread" data-thread-key="2016/06/25/多线程系列之GCD/"
           data-title="多线程系列之GCD之一" data-url="http://yoursite.com/2016/06/25/多线程系列之GCD/">
      </div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.png"
               alt="ySenIn" />
          <p class="site-author-name" itemprop="name">ySenIn</p>
          <p class="site-description motion-element" itemprop="description">一个孤独的人，一个不想孤独的人</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">14</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">9</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">19</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

      </section>

      
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">
            
              
            
            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#前言"><span class="nav-number">1.</span> <span class="nav-text">前言</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#线程"><span class="nav-number">2.</span> <span class="nav-text">线程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#同步"><span class="nav-number">2.1.</span> <span class="nav-text">同步</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#异步"><span class="nav-number">2.2.</span> <span class="nav-text">异步</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#dispatch-queue-create创建"><span class="nav-number">2.2.1.</span> <span class="nav-text">dispatch_queue_create创建</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Global-Dispatch-Queue创建"><span class="nav-number">2.2.2.</span> <span class="nav-text">Global Dispatch Queue创建</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#dispatch-set-target-queue"><span class="nav-number">2.2.3.</span> <span class="nav-text">dispatch_set_target_queue</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#dispatch-after"><span class="nav-number">2.2.4.</span> <span class="nav-text">dispatch_after</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Dispatch-Group"><span class="nav-number">2.2.5.</span> <span class="nav-text">Dispatch Group</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#dispatch-barrier-async"><span class="nav-number">2.2.6.</span> <span class="nav-text">dispatch_barrier_async</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#dispatch-apply"><span class="nav-number">2.2.7.</span> <span class="nav-text">dispatch_apply</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#dispatch-suspend-dispatch-resume"><span class="nav-number">2.2.8.</span> <span class="nav-text">dispatch_suspend/dispatch_resume</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#dispatch-once"><span class="nav-number">2.2.9.</span> <span class="nav-text">dispatch_once</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#后记"><span class="nav-number">3.</span> <span class="nav-text">后记</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#参考文献"><span class="nav-number">4.</span> <span class="nav-text">参考文献</span></a></li></ol></div>
            
          </div>
        </section>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
  <span id="busuanzi_container_site_pv">pv: <span id="busuanzi_value_site_pv"></span></span>
  <span id="busuanzi_container_site_uv">uv: <span id="busuanzi_value_site_uv"></span></span>
  <span class="author" itemprop="copyrightHolder">ySenIn</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.0.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.0.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"ysenin"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
  





  
  
  

  

  

</body>
</html>
