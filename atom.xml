<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ySenIn&#39;s Blog</title>
  <subtitle>ySen</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-10-20T03:11:52.256Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>ySenIn</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>pinyin4objc源码阅读</title>
    <link href="http://yoursite.com/2017/10/19/pinyin4objc%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    <id>http://yoursite.com/2017/10/19/pinyin4objc源码阅读/</id>
    <published>2017-10-19T06:43:32.000Z</published>
    <updated>2017-10-20T03:11:52.256Z</updated>
    
    <content type="html">&lt;p&gt;源码参见：&lt;a href=&quot;https://github.com/kimziv/PinYin4Objc.git&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/kimziv/PinYin4Objc.git&lt;/a&gt;&lt;br&gt;版本：1.1&lt;/p&gt;
&lt;h3 id=&quot;描述&quot;&gt;&lt;a href=&quot;#描述&quot; class=&quot;headerlink&quot; title=&quot;描述&quot;&gt;&lt;/a&gt;描述&lt;/h3&gt;&lt;p&gt;汉字转拼音，相信在很多app都会遇到，例如：通讯录、消息、搜索等。汉字转拼音有很多种方式可以是实现，本文所讲的是其中一种；当然，苹果也有自己的实现方式。苹果内部实现就真心不想吐槽了，超级慢，后续会找一些数据来说明。那么，接下来就看看PinYin4Objc是如何实现高效的转化。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;前注&quot;&gt;&lt;a href=&quot;#前注&quot; class=&quot;headerlink&quot; title=&quot;前注&quot;&gt;&lt;/a&gt;前注&lt;/h3&gt;&lt;h4 id=&quot;常量、枚举&quot;&gt;&lt;a href=&quot;#常量、枚举&quot; class=&quot;headerlink&quot; title=&quot;常量、枚举&quot;&gt;&lt;/a&gt;常量、枚举&lt;/h4&gt;&lt;p&gt;在阅读源码之前，我们需要认识一下PinYin4Objc里面的常量以及枚举值：&lt;br&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;#define HANYU_PINYIN @&amp;quot;Hanyu&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#define WADEGILES_PINYIN @&amp;quot;Wade&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#define MPS2_PINYIN @&amp;quot;MPSII&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#define YALE_PINYIN @&amp;quot;Yale&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#define TONGYONG_PINYIN @&amp;quot;Tongyong&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#define GWOYEU_ROMATZYH @&amp;quot;Gwoyeu&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;MPS2_PINYIN：注音符号第二式&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;YALE_PINYIN：耶鲁拼法&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;HANYU_PINYIN：汉语拼音&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;TONGYONG_PINYIN：通用拼音&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;GWOYEU_ROMATZYH：国语罗马字&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;WADEGILES_PINYIN：威妥玛拼音(威玛拼法)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;/*&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; 音调，例：刘&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;typedef enum &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  ToneTypeWithToneNumber,   // 用数字表示声调，例如：liu2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  ToneTypeWithoutTone,      // 无音调，例如：liu&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  ToneTypeWithToneMark      // 用声调符号表示，例如：liú&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125; ToneType;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;/*&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; 大小写，例：国&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;typedef enum &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    CaseTypeUppercase,  // GUÓ&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    CaseTypeLowercase   // guó&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125; CaseType;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;/*&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; unicode 的ü 、v 和 u时的显示方式，例：吕&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;typedef enum &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    VCharTypeWithUAndColon, // lu:3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    VCharTypeWithV,         // lv3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    VCharTypeWithUUnicode   // lü3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125; VCharType;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;前面的代码参考&lt;a href=&quot;http://www.cnblogs.com/mthoutai/p/6745293.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;java 中文转拼音之pinyin4j&lt;/a&gt;。当然，在移动端其实并不会使用太多格式，因此简单介绍，并不作说明。详情可以参见外链的文章。&lt;/p&gt;
&lt;h4 id=&quot;类&quot;&gt;&lt;a href=&quot;#类&quot; class=&quot;headerlink&quot; title=&quot;类&quot;&gt;&lt;/a&gt;类&lt;/h4&gt;&lt;p&gt;源代码中就只有几个文件，代码逻辑也不会很复杂。在深入阅读代码之前，需要搞清楚几个文件的作用。接下来简单描述项目中的类：&lt;br&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;ChineseToPinyinResource: 拼音转汉字的文件&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;HanyuPinyinOutputFormat: 输出格式定义&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;NSString+PinYin4Cocoa: 工具方法转换&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;PinyinFormatter: 按照输出格式，格式化返回字符&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;PinyinHelper: 开源库的使用方法文件&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;unicode_to_hanyu_pinyin: unicode编码字典文件（每个汉字，对应一个unicode编码）&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;转换思想&quot;&gt;&lt;a href=&quot;#转换思想&quot; class=&quot;headerlink&quot; title=&quot;转换思想&quot;&gt;&lt;/a&gt;转换思想&lt;/h3&gt;&lt;p&gt;pinyin4objc实际上是参考java当中的pinyin4j。核心思想也非常简单，在我们调用汉字转拼音之时，会生成一个单例对象。单例里面所做的事情就是：从沙盒独出读出unicode字典，如果独处失败，会将unicode_to_hanyu_pinyin文件中的数据读取到字典中，然后再将此字典以二进制的方式将数据缓存在沙盒中，以供以后使用。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (void)initializeResource &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    /*&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     1. 首先判断沙盒是否存在，如果沙盒存在则直接使用沙盒数据&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     2. 如果沙盒不存在，则读取资源文件数据，最后将资源文件数据通过二进制的方式直接缓存到沙盒&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    NSString* cachesDirectory = NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES)[0];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	_directory = [[[cachesDirectory stringByAppendingPathComponent:[[NSBundle mainBundle] bundleIdentifier]] stringByAppendingPathComponent:@&amp;quot;PinYinCache&amp;quot;] copy];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    NSFileManager *fileManager = [NSFileManager defaultManager];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if (![fileManager fileExistsAtPath:_directory]) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        NSError *error = nil;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        if (![fileManager createDirectoryAtPath:_directory withIntermediateDirectories:YES attributes:nil error:&amp;amp;error]) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            PYLog(@&amp;quot;Error, s is %@, %s, %s, %d&amp;quot;,error.description, __FILE__ ,__FUNCTION__, __LINE__);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    NSDictionary *dataMap = (NSDictionary *)[self cachedObjectForKey:kCacheKeyForUnicode2Pinyin];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if (dataMap) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        self-&amp;gt;_unicodeToHanyuPinyinTable = dataMap;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125; else &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        NSString *resourceName = [[NSBundle mainBundle] pathForResource:@&amp;quot;unicode_to_hanyu_pinyin&amp;quot; ofType:@&amp;quot;txt&amp;quot;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        NSString *dictionaryText = [NSString stringWithContentsOfFile:resourceName encoding:NSUTF8StringEncoding error:nil];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        NSArray *lines = [dictionaryText componentsSeparatedByString:@&amp;quot;\r\n&amp;quot;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        __block NSMutableDictionary *tempMap=[[NSMutableDictionary alloc] init];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        @autoreleasepool &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                [lines enumerateObjectsUsingBlock:^(id obj, NSUInteger idx, BOOL *stop) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    NSArray *lineComponents = [obj componentsSeparatedByCharactersInSet:[NSCharacterSet whitespaceCharacterSet]];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    [tempMap setObject:lineComponents[1] forKey:lineComponents[0]];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &amp;#125;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        self-&amp;gt;_unicodeToHanyuPinyinTable = tempMap;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        [self cacheObjec:self-&amp;gt;_unicodeToHanyuPinyinTable forKey:kCacheKeyForUnicode2Pinyin];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;将中文作为key，从字典中可以得到某种格式的拼音，在使用过程当中，按照自定义格式转换成最终所使用的格式即可。&lt;/p&gt;
&lt;h3 id=&quot;数据&quot;&gt;&lt;a href=&quot;#数据&quot; class=&quot;headerlink&quot; title=&quot;数据&quot;&gt;&lt;/a&gt;数据&lt;/h3&gt;&lt;p&gt;由上述代码我们能看到，第一次安装使用是从文件中读取数据，从某种意义上来见，这是比较慢的。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;字符数&lt;/th&gt;
&lt;th&gt;次数&lt;/th&gt;
&lt;th&gt;时间(秒)&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;19440&lt;/td&gt;
&lt;td&gt;第一次&lt;/td&gt;
&lt;td&gt;0.3546s&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;19440&lt;/td&gt;
&lt;td&gt;第二次&lt;/td&gt;
&lt;td&gt;0.2665s&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;19440&lt;/td&gt;
&lt;td&gt;第三次&lt;/td&gt;
&lt;td&gt;0.2535s&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;9&lt;/td&gt;
&lt;td&gt;第一次&lt;/td&gt;
&lt;td&gt;0.1158s&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;9&lt;/td&gt;
&lt;td&gt;第二次&lt;/td&gt;
&lt;td&gt;0.0010s&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;9&lt;/td&gt;
&lt;td&gt;第三次&lt;/td&gt;
&lt;td&gt;0.0015s&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;从数据来看，首次加载大概会消耗0.1s的时间加载文件。当然，在实际使用当中，首次消耗时间是可以接受的。&lt;/p&gt;
&lt;p&gt;从数据我们能看到，pinyin4objc的转换效率还是非常快的。但是，由于我们使用的是单例模式，单例对象在整个生命周期中持有了拼音文件的dictionary，这也导致这么内存在生命周期内一直存在，此处提出一个疑问。&lt;/p&gt;
&lt;h3 id=&quot;官方转换&quot;&gt;&lt;a href=&quot;#官方转换&quot; class=&quot;headerlink&quot; title=&quot;官方转换&quot;&gt;&lt;/a&gt;官方转换&lt;/h3&gt;&lt;p&gt;上述提到了第三方库的转换，再来看看苹果内部是如何转换的呢😀😀😀。在网上找了一段代码，代码如下：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;+ (NSString *)transform:(NSString *)chinese&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    NSMutableString *pinyin = [chinese mutableCopy];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    CFStringTransform((__bridge CFMutableStringRef)pinyin, NULL, kCFStringTransformMandarinLatin, NO);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    CFStringTransform((__bridge CFMutableStringRef)pinyin, NULL, kCFStringTransformStripCombiningMarks, NO);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    NSLog(@&amp;quot;%@&amp;quot;, pinyin);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return [pinyin uppercaseString];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;测试数据如下：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;字符数&lt;/th&gt;
&lt;th&gt;次数&lt;/th&gt;
&lt;th&gt;时间(秒)&lt;/th&gt;
&lt;th&gt;使用方法&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;2693 * 100&lt;/td&gt;
&lt;td&gt;第一次&lt;/td&gt;
&lt;td&gt;5.3802s&lt;/td&gt;
&lt;td&gt;苹果内置&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2693 * 100&lt;/td&gt;
&lt;td&gt;第二次&lt;/td&gt;
&lt;td&gt;5.1389s&lt;/td&gt;
&lt;td&gt;苹果内置&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2693 * 100&lt;/td&gt;
&lt;td&gt;第三次&lt;/td&gt;
&lt;td&gt;4.9573s&lt;/td&gt;
&lt;td&gt;苹果内置&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;164  * 100&lt;/td&gt;
&lt;td&gt;第一次&lt;/td&gt;
&lt;td&gt;0.5060s&lt;/td&gt;
&lt;td&gt;苹果内置&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;164  * 100&lt;/td&gt;
&lt;td&gt;第二次&lt;/td&gt;
&lt;td&gt;0.4096s&lt;/td&gt;
&lt;td&gt;苹果内置&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;164  * 100&lt;/td&gt;
&lt;td&gt;第三次&lt;/td&gt;
&lt;td&gt;0.4152s&lt;/td&gt;
&lt;td&gt;苹果内置&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2693 * 100&lt;/td&gt;
&lt;td&gt;第一次&lt;/td&gt;
&lt;td&gt;1.9244s&lt;/td&gt;
&lt;td&gt;pinyin4obj&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2693 * 100&lt;/td&gt;
&lt;td&gt;第二次&lt;/td&gt;
&lt;td&gt;1.7063s&lt;/td&gt;
&lt;td&gt;pinyin4obj&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2693 * 100&lt;/td&gt;
&lt;td&gt;第三次&lt;/td&gt;
&lt;td&gt;1.6897s&lt;/td&gt;
&lt;td&gt;pinyin4obj&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;164  * 100&lt;/td&gt;
&lt;td&gt;第一次&lt;/td&gt;
&lt;td&gt;0.2228s&lt;/td&gt;
&lt;td&gt;pinyin4obj&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;164  * 100&lt;/td&gt;
&lt;td&gt;第二次&lt;/td&gt;
&lt;td&gt;0.1340s&lt;/td&gt;
&lt;td&gt;pinyin4obj&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;164  * 100&lt;/td&gt;
&lt;td&gt;第三次&lt;/td&gt;
&lt;td&gt;0.1017s&lt;/td&gt;
&lt;td&gt;pinyin4obj&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;从测试数据可以看出，苹果内置转换要比pinyin4objc耗时多3-5倍。因此，在使用过程当中，要尽量考虑出数据量的大小，选择自己需要的解决办法。&lt;/p&gt;
&lt;h3 id=&quot;后记&quot;&gt;&lt;a href=&quot;#后记&quot; class=&quot;headerlink&quot; title=&quot;后记&quot;&gt;&lt;/a&gt;后记&lt;/h3&gt;&lt;p&gt;记得曾今在项目中使用过两次汉字转拼音的功能，一次是数据量特别少，因此在使用过程当中完全不知道耗时的事情。接下来就是现在这个项目，测试报了一个bug说大概半分钟才会出现数据，当时也不清楚是什么问题，最后详查了一下，定位是汉字转拼音的问题。真是崩溃啊，当时的解决方案是暂时不使用汉字转拼音，忽略掉耗时的请求了。最近，因为需要做本地搜索，所以很多数据需要，就从新调研了一下汉字转拼音的库。&lt;/p&gt;
&lt;p&gt;总体来讲，pinyin4objc的性能还是比较好的，转花效率还是蛮高的。至于占用的内存，算算也还可以接受。因此，还是蛮推荐大家使用的。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;源码参见：&lt;a href=&quot;https://github.com/kimziv/PinYin4Objc.git&quot;&gt;https://github.com/kimziv/PinYin4Objc.git&lt;/a&gt;&lt;br&gt;版本：1.1&lt;/p&gt;
&lt;h3 id=&quot;描述&quot;&gt;&lt;a href=&quot;#描述&quot; class=&quot;headerlink&quot; title=&quot;描述&quot;&gt;&lt;/a&gt;描述&lt;/h3&gt;&lt;p&gt;汉字转拼音，相信在很多app都会遇到，例如：通讯录、消息、搜索等。汉字转拼音有很多种方式可以是实现，本文所讲的是其中一种；当然，苹果也有自己的实现方式。苹果内部实现就真心不想吐槽了，超级慢，后续会找一些数据来说明。那么，接下来就看看PinYin4Objc是如何实现高效的转化。&lt;/p&gt;
    
    </summary>
    
      <category term="源码剖析" scheme="http://yoursite.com/categories/%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"/>
    
    
      <category term="源码剖析" scheme="http://yoursite.com/tags/%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>SDWebImage之SDWebImageDownloader相关</title>
    <link href="http://yoursite.com/2016/07/19/SDWebImage%E4%B9%8BSDWebImageDownloader%E7%9B%B8%E5%85%B3/"/>
    <id>http://yoursite.com/2016/07/19/SDWebImage之SDWebImageDownloader相关/</id>
    <published>2016-07-18T16:55:29.000Z</published>
    <updated>2016-07-18T16:57:14.000Z</updated>
    
    <content type="html"></content>
    
    <summary type="html">
    
    </summary>
    
      <category term="源码剖析" scheme="http://yoursite.com/categories/%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"/>
    
    
      <category term="源码剖析" scheme="http://yoursite.com/tags/%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"/>
    
      <category term="SDWebImage" scheme="http://yoursite.com/tags/SDWebImage/"/>
    
      <category term="SDWebImageDownloader" scheme="http://yoursite.com/tags/SDWebImageDownloader/"/>
    
  </entry>
  
  <entry>
    <title>SDWebImage源码之SDImageCache</title>
    <link href="http://yoursite.com/2016/07/19/SDWebImage%E6%BA%90%E7%A0%81%E4%B9%8BSDImageCache/"/>
    <id>http://yoursite.com/2016/07/19/SDWebImage源码之SDImageCache/</id>
    <published>2016-07-18T16:36:26.000Z</published>
    <updated>2017-10-20T03:34:17.971Z</updated>
    
    <content type="html">&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;SDImageCache类是实现图片缓存的类，此类的缓存分为两种：磁盘缓存、保留在内存。通俗的说就是前者保存在沙盒，后者停留在内存中。问题在于，沙盒读写比较耗时，保存在内存中比较占内存，可能存在因内存过大而崩溃。对于沙盒读写耗时，如果文件不大，手机读写速度快，那也是毫厘之间的时间就能完成的。内存占有率大，这个苹果的NSCache就给我们提供了相应的方法，可以在一定程度上降低内存占有率和防止应用崩溃，关于NSCache可以看另外一篇文章&lt;a href=&quot;http://blog.ysenin.com/2016/07/17/NSCache%E7%9B%B8%E5%85%B3%E8%A7%A3%E8%AF%BB/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;NSCache相关解读&lt;/a&gt;。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;缓存类型&quot;&gt;&lt;a href=&quot;#缓存类型&quot; class=&quot;headerlink&quot; title=&quot;缓存类型&quot;&gt;&lt;/a&gt;缓存类型&lt;/h3&gt;&lt;p&gt;SDImageCache提供了三种枚举类型，如下：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;// 读取缓存枚举类型&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;typedef NS_ENUM(NSInteger, SDImageCacheType) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    SDImageCacheTypeNone, // image不可用于SDWebImage缓存，但可以从网络下载&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    SDImageCacheTypeDisk, // 图片可以从磁盘缓存空间获取&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    SDImageCacheTypeMemory // 图片从内存空间获取&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;如上，我们读取缓存的时候，可以从网络上下载，从磁盘读区，也可以从内存空间获得。当然，具体是怎样实现由具体的技术实现来完成。&lt;/p&gt;
&lt;h3 id=&quot;Block&quot;&gt;&lt;a href=&quot;#Block&quot; class=&quot;headerlink&quot; title=&quot;Block&quot;&gt;&lt;/a&gt;Block&lt;/h3&gt;&lt;p&gt;在SDImageCache中，给我们提供了三个block&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;// 通过key查询，缓存（内存和磁盘）是否存在缓存，并返回图片数据和缓存来源&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;typedef void(^SDWebImageQueryCompletedBlock)(UIImage *image, SDImageCacheType cacheType);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 检查key是否存在磁盘缓存中&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;typedef void(^SDWebImageCheckCacheCompletionBlock)(BOOL isInCache);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 计算磁盘缓存大小，返回磁盘缓存数目和总大小&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;typedef void(^SDWebImageCalculateSizeBlock)(NSUInteger fileCount, NSUInteger totalSize);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;如注释所示，前两个block查询key的缓存数据，第三个block是计算磁盘缓存大小。这几个block在后面的代码实现中有很重要的作用，因此我们做一个重要了解。&lt;/p&gt;
&lt;h3 id=&quot;属性&quot;&gt;&lt;a href=&quot;#属性&quot; class=&quot;headerlink&quot; title=&quot;属性&quot;&gt;&lt;/a&gt;属性&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;/**&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * 此属性主要用于gif图片类，解压被下载并缓存的图片可以提高性能，但是会消耗很多内存，默认为yes，如果遇到因为内存消耗过大而导致崩溃，可以设置为no&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@property (assign, nonatomic) BOOL shouldDecompressImages;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 允许iCloud备份，默认为yes&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@property (assign, nonatomic) BOOL shouldDisableiCloud;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 使用内存缓存，默认yes&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@property (assign, nonatomic) BOOL shouldCacheImagesInMemory;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 内存中图片最大的缓存花费（最大缓存容量），花费的方法是保留在内存中的像素个数&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@property (assign, nonatomic) NSUInteger maxMemoryCost;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 最大可以缓存的图片对象&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@property (assign, nonatomic) NSUInteger maxMemoryCountLimit;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 图片最长缓存时间&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@property (assign, nonatomic) NSInteger maxCacheAge;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 最大比特缓存&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@property (assign, nonatomic) NSUInteger maxCacheSize;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;关于属性，事实上和NSCache的属性差不多。这里需要说一下&lt;strong&gt;maxCacheAge&lt;/strong&gt;的实现方式。maxCacheAge如注释所示，代表最长的缓存时间，这里仅仅是针对于磁盘缓存而言。maxCacheAge仅仅是一个相对的时间，并不是绝对的。从源码可以看出，磁盘缓存清理会到用到&lt;strong&gt;- (void)cleanDiskWithCompletionBlock:(SDWebImageNoParamsBlock)completionBlock&lt;/strong&gt;方法，在此方法，系统会去检索磁盘，是否存在缓存文件，并读出可用路径。之后通过文件最后修改的时间，和离现在maxCacheAge之前的时间节点时间相互比较，判断是否应该删除。那么&lt;strong&gt;重点&lt;/strong&gt;在于，在什么地方会调用此方法呢？还是回到源码，如下代码可以发现问题：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (id)initWithNamespace:(NSString *)ns diskCacheDirectory:(NSString *)directory &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if ((self = [super init])) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        /* 各种初始化 */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        // 程序受到内存警告，需要进行内存缓存清理&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        [[NSNotificationCenter defaultCenter] addObserver:self&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                                                 selector:@selector(clearMemory)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                                                     name:UIApplicationDidReceiveMemoryWarningNotification&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                                                   object:nil];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        // 程序即将被终止（被杀死）,清理磁盘缓存&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        [[NSNotificationCenter defaultCenter] addObserver:self&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                                                 selector:@selector(cleanDisk)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                                                     name:UIApplicationWillTerminateNotification&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                                                   object:nil];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        // 程序进入后台后，需要清理的磁盘缓存&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        [[NSNotificationCenter defaultCenter] addObserver:self&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                                                 selector:@selector(backgroundCleanDisk)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                                                     name:UIApplicationDidEnterBackgroundNotification&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                                                   object:nil];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return self;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;从上面代码，我们在新建缓存类的时候注册了三个监听事件。从后面两个监听我们可以看到程序在即将被终止是会调用一次磁盘清理，在程序进入后台需要清理一次。假如程序长时间留在前台，且不被杀死，超过了maxCacheAge时间，缓存磁盘文件还是可能存在于磁盘的。这也就是为啥，说磁盘maxCacheAge是相对的。&lt;/p&gt;
&lt;h3 id=&quot;方法&quot;&gt;&lt;a href=&quot;#方法&quot; class=&quot;headerlink&quot; title=&quot;方法&quot;&gt;&lt;/a&gt;方法&lt;/h3&gt;&lt;p&gt;针对SDImageCache的方法，这里只会给出几个重要的方法实现，因为其它都是针对于这几个方法，通过不同的参数形成的。首先缓存很重要的一个东西就是key，这个就是图片的url，由于直接存储url不是特别聪明的办法，因此作者将url转换成了md5编码，取其16进制的编码作为最终的key。然后，磁盘缓存一般都是异步读写。&lt;/p&gt;
&lt;h4 id=&quot;磁盘存储&quot;&gt;&lt;a href=&quot;#磁盘存储&quot; class=&quot;headerlink&quot; title=&quot;磁盘存储&quot;&gt;&lt;/a&gt;磁盘存储&lt;/h4&gt;&lt;p&gt;磁盘存储都会统一调用下面这两个方法的代码，具体的可以结合源代码和注释来看，这会让你在读代码时事半功倍。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;47&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;48&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;49&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;50&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;51&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;52&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;53&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;54&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;55&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;56&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;57&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;58&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;59&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;60&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;61&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;62&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;63&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;64&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;65&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;66&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;67&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;68&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;69&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;70&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;71&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;72&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;73&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;// 缓存图片（image，是否从新计算，图片数据，key，是否磁盘缓存）&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (void)storeImage:(UIImage *)image recalculateFromImage:(BOOL)recalculate imageData:(NSData *)imageData forKey:(NSString *)key toDisk:(BOOL)toDisk &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if (!image || !key) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    // 如果允许内存缓存&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if (self.shouldCacheImagesInMemory) &amp;#123; // 内存缓存&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        NSUInteger cost = SDCacheCostForImage(image);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        [self.memCache setObject:image forKey:key cost:cost]; // 跳至内存缓存的方法&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if (toDisk) &amp;#123; // 进行异步磁盘缓存&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        dispatch_async(self.ioQueue, ^&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            NSData *data = imageData;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            if (image &amp;amp;&amp;amp; (recalculate || !data)) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#if TARGET_OS_IPHONE // 是否是iOS平台&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                int alphaInfo = CGImageGetAlphaInfo(image.CGImage); // 获取图片的通道信息&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                BOOL hasAlpha = !(alphaInfo == kCGImageAlphaNone ||&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                                  alphaInfo == kCGImageAlphaNoneSkipFirst ||&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                                  alphaInfo == kCGImageAlphaNoneSkipLast);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                BOOL imageIsPng = hasAlpha; // 是否有alpha通道&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                // But if we have an image data, we will look at the preffix&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                if ([imageData length] &amp;gt;= [kPNGSignatureData length]) &amp;#123; // 判断数据的前8个字节，以确定使用哪种转换方式&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    imageIsPng = ImageDataHasPNGPreffix(imageData);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                if (imageIsPng) &amp;#123; // png 格式&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    data = UIImagePNGRepresentation(image);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                else &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    data = UIImageJPEGRepresentation(image, (CGFloat)1.0);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#else&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                data = [NSBitmapImageRep representationOfImageRepsInArray:image.representations usingType: NSJPEGFileType properties:nil];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#endif&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            [self storeImageDataToDisk:data forKey:key]; // 通过key进行磁盘缓存&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 磁盘缓存，通过key&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (void)storeImageDataToDisk:(NSData *)imageData forKey:(NSString *)key &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if (!imageData) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    // 判断磁盘缓存路径是否存在，若不存在则创建磁盘缓存路径&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if (![_fileManager fileExistsAtPath:_diskCachePath]) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        [_fileManager createDirectoryAtPath:_diskCachePath withIntermediateDirectories:YES attributes:nil error:NULL];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    // get cache Path for image key&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    // 缓存文件路径&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    NSString *cachePathForKey = [self defaultCachePathForKey:key]; // md5之后的url&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    // transform to NSUrl&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    // 转换成nsurl&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    NSURL *fileURL = [NSURL fileURLWithPath:cachePathForKey];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    // 创建缓存文件&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [_fileManager createFileAtPath:cachePathForKey contents:imageData attributes:nil];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    // disable iCloud backup&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    // 启用iCloud备份&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if (self.shouldDisableiCloud) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        [fileURL setResourceValue:[NSNumber numberWithBool:YES] forKey:NSURLIsExcludedFromBackupKey error:nil];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h4 id=&quot;磁盘查找&quot;&gt;&lt;a href=&quot;#磁盘查找&quot; class=&quot;headerlink&quot; title=&quot;磁盘查找&quot;&gt;&lt;/a&gt;磁盘查找&lt;/h4&gt;&lt;p&gt;磁盘查找需要注意一点的就是，在文件存储的时候，可能存在没有后缀扩展名的存在，因此需要检查两次，依次是存在扩展名，一次是不存在扩展名。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;// 判断磁盘文件是否存在key的缓存文件&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (BOOL)diskImageExistsWithKey:(NSString *)key &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    BOOL exists = NO;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    // 这是期望通过连接文件管理在其他的io队列，但是我们使用了单例,来自苹果官方文档的解释是：文件管理的单例对象方法，在多线程能安全的调用。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    // 通过key获取缓存文件路径&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    exists = [[NSFileManager defaultManager] fileExistsAtPath:[self defaultCachePathForKey:key]];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    // 根据https://github.com/rs/SDWebImage/pull/976，可能key添加了后缀扩展名,因此需要判断key是否存在后缀扩展名&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if (!exists) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        // key存在后缀，需要删除扩展名，只保留文件名&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        exists = [[NSFileManager defaultManager] fileExistsAtPath:[[self defaultCachePathForKey:key] stringByDeletingPathExtension]];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return exists;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 方法作用同上，只是实现了异步判断，添加回调block&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (void)diskImageExistsWithKey:(NSString *)key completion:(SDWebImageCheckCacheCompletionBlock)completionBlock &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    dispatch_async(_ioQueue, ^&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        BOOL exists = [_fileManager fileExistsAtPath:[self defaultCachePathForKey:key]];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        if (!exists) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            exists = [_fileManager fileExistsAtPath:[[self defaultCachePathForKey:key] stringByDeletingPathExtension]];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        // 异步结束，执行回调&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        if (completionBlock) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            dispatch_async(dispatch_get_main_queue(), ^&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                completionBlock(exists);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h4 id=&quot;磁盘删除&quot;&gt;&lt;a href=&quot;#磁盘删除&quot; class=&quot;headerlink&quot; title=&quot;磁盘删除&quot;&gt;&lt;/a&gt;磁盘删除&lt;/h4&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (void)removeImageForKey:(NSString *)key fromDisk:(BOOL)fromDisk withCompletion:(SDWebImageNoParamsBlock)completion &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if (key == nil) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    // 从内存删除gif数据&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if (self.shouldCacheImagesInMemory) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        [self.memCache removeObjectForKey:key];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if (fromDisk) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        dispatch_async(self.ioQueue, ^&amp;#123; // 异步队列&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            // 删除路径下的数据&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            [_fileManager removeItemAtPath:[self defaultCachePathForKey:key] error:nil];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            if (completion) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                dispatch_async(dispatch_get_main_queue(), ^&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    completion();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125; else if (completion)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        completion();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h4 id=&quot;内存缓存&quot;&gt;&lt;a href=&quot;#内存缓存&quot; class=&quot;headerlink&quot; title=&quot;内存缓存&quot;&gt;&lt;/a&gt;内存缓存&lt;/h4&gt;&lt;p&gt;SDImageCache两种缓存方式：磁盘缓存、内存缓存。上面介绍了磁盘缓存的一些读写的重要方法，那么内存缓存SDImageCache则是使用了NSCache的方式去完成的。因此，如果想学习NSCache可以看我另外一篇文章，也可以自己百度，那一块儿就不再深入探究了。&lt;/p&gt;
&lt;h3 id=&quot;后记&quot;&gt;&lt;a href=&quot;#后记&quot; class=&quot;headerlink&quot; title=&quot;后记&quot;&gt;&lt;/a&gt;后记&lt;/h3&gt;&lt;p&gt;至此，关于SDImageCache的讲解就到此结束了。上面存在的源码比较多，当然也有一定的文字描述。里面提到了一些重要的知识点，还望细细品尝，如果有啥问题可以留言给我。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;SDImageCache类是实现图片缓存的类，此类的缓存分为两种：磁盘缓存、保留在内存。通俗的说就是前者保存在沙盒，后者停留在内存中。问题在于，沙盒读写比较耗时，保存在内存中比较占内存，可能存在因内存过大而崩溃。对于沙盒读写耗时，如果文件不大，手机读写速度快，那也是毫厘之间的时间就能完成的。内存占有率大，这个苹果的NSCache就给我们提供了相应的方法，可以在一定程度上降低内存占有率和防止应用崩溃，关于NSCache可以看另外一篇文章&lt;a href=&quot;http://blog.ysenin.com/2016/07/17/NSCache%E7%9B%B8%E5%85%B3%E8%A7%A3%E8%AF%BB/&quot;&gt;NSCache相关解读&lt;/a&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="源码剖析" scheme="http://yoursite.com/categories/%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"/>
    
    
      <category term="源码剖析" scheme="http://yoursite.com/tags/%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"/>
    
      <category term="SDWebImage" scheme="http://yoursite.com/tags/SDWebImage/"/>
    
      <category term="Cache" scheme="http://yoursite.com/tags/Cache/"/>
    
  </entry>
  
  <entry>
    <title>NSCache相关解读</title>
    <link href="http://yoursite.com/2016/07/17/NSCache%E7%9B%B8%E5%85%B3%E8%A7%A3%E8%AF%BB/"/>
    <id>http://yoursite.com/2016/07/17/NSCache相关解读/</id>
    <published>2016-07-16T17:47:52.000Z</published>
    <updated>2017-10-20T03:11:40.727Z</updated>
    
    <content type="html">&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;说实话，最近在看SDWebImage，里面很重要的一部分就是讲缓存这个知识点。那么，写这篇文章的前半个小时，是准备写SDWebImage的源码分析的。但因为强迫症，觉得需要讲清楚缓存相关的概念，才能继续往下讲SDWebImage。因此，这篇文章，主要讲NSCache相关的知识点，以及其他方式构建缓存的优缺点。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;NSCache介绍与基本使用&quot;&gt;&lt;a href=&quot;#NSCache介绍与基本使用&quot; class=&quot;headerlink&quot; title=&quot;NSCache介绍与基本使用&quot;&gt;&lt;/a&gt;NSCache介绍与基本使用&lt;/h3&gt;&lt;p&gt;这是一个非常简单的缓存管理类，以key-value对的形式进行存储。是不是感觉和NSMutableDictionary非常相似呢？没错，在iOS 4之前，苹果就是以NSMutableDictionary的形势做缓存的，至于两者的区别会在接下来的文章里提到。在项目中，新建一个NSCache对象，点击进入NSCache类中，我们就可以看到NSCache给我们提供的几个简单的属性和方法。&lt;/p&gt;
&lt;h4 id=&quot;属性&quot;&gt;&lt;a href=&quot;#属性&quot; class=&quot;headerlink&quot; title=&quot;属性&quot;&gt;&lt;/a&gt;属性&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;@property (copy) NSString *name; // 名称&lt;br&gt;@property (nullable, assign) id&lt;nscachedelegate&gt; delegate; // 代理&lt;br&gt;@property NSUInteger totalCostLimit;    // 最大缓存容量上限&lt;br&gt;@property NSUInteger countLimit;    // 最大缓存容量对象个数&lt;br&gt;@property BOOL evictsObjectsWithDiscardedContent; // 是否允许退出对象丢弃缓存内容&lt;/nscachedelegate&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这里需要重点讲的只有totalCostLimit和countLimit两个属性，如注释所看到的，一个是最大缓存容量上限和最大缓存对象个数。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;  1.totalCostLimit：默认为0，表示没有最大的缓存上限；当不为0时，我们在添加的缓存数据超过totalCostLimit，NSCache会自动帮我们移除一个或多个缓存对象，以保证我们添加缓存数据之后的大小不会超过最大的缓存容量。&lt;br&gt;  2.countLimit: 默认为0，表示没有最大的缓存上限个数；当不为0时，我们逐个添加缓存时，会计算是否超过最大的缓存数量个数，若超过则会自动释放其中一个。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;当然，上面两个属性并不是一个严格的限制。当缓存数据超过限制时，可能会立即丢弃、稍后或者永不丢弃，具体的得看具体的实现细节。&lt;/p&gt;
&lt;h4 id=&quot;方法&quot;&gt;&lt;a href=&quot;#方法&quot; class=&quot;headerlink&quot; title=&quot;方法&quot;&gt;&lt;/a&gt;方法&lt;/h4&gt;&lt;p&gt;NSCache提供了一组方法来存取key－value对，通过下面的方法就可以设置缓存数据。&lt;br&gt;&lt;figure class=&quot;highlight swift&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (nullable &lt;span class=&quot;type&quot;&gt;ObjectType&lt;/span&gt;)objectForKey:(&lt;span class=&quot;type&quot;&gt;KeyType&lt;/span&gt;)key; &lt;span class=&quot;comment&quot;&gt;// 获取key的缓存数据&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (void)setObject:(&lt;span class=&quot;type&quot;&gt;ObjectType&lt;/span&gt;)obj forKey:(&lt;span class=&quot;type&quot;&gt;KeyType&lt;/span&gt;)key; &lt;span class=&quot;comment&quot;&gt;// 0 cost, 设置key的缓存数据，默认缓存花费为0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (void)setObject:(&lt;span class=&quot;type&quot;&gt;ObjectType&lt;/span&gt;)obj forKey:(&lt;span class=&quot;type&quot;&gt;KeyType&lt;/span&gt;)key cost:(&lt;span class=&quot;type&quot;&gt;NSUInteger&lt;/span&gt;)g; &lt;span class=&quot;comment&quot;&gt;// 同上，缓存花费为g&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (void)removeObjectForKey:(&lt;span class=&quot;type&quot;&gt;KeyType&lt;/span&gt;)key; &lt;span class=&quot;comment&quot;&gt;// 移除key的缓存数据&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (void)removeAllObjects; &lt;span class=&quot;comment&quot;&gt;// 移除所有缓存数据&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// delegate&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (void)cache:(&lt;span class=&quot;type&quot;&gt;NSCache&lt;/span&gt; *)cache willEvictObject:(id)obj; &lt;span class=&quot;comment&quot;&gt;// 被移除的缓存数据对象&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;特别需要说明的两个方法如下：&lt;br&gt;&lt;figure class=&quot;highlight swift&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (void)setObject:(&lt;span class=&quot;type&quot;&gt;ObjectType&lt;/span&gt;)obj forKey:(&lt;span class=&quot;type&quot;&gt;KeyType&lt;/span&gt;)key; &lt;span class=&quot;comment&quot;&gt;// 方法一&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (void)setObject:(&lt;span class=&quot;type&quot;&gt;ObjectType&lt;/span&gt;)obj forKey:(&lt;span class=&quot;type&quot;&gt;KeyType&lt;/span&gt;)key cost:(&lt;span class=&quot;type&quot;&gt;NSUInteger&lt;/span&gt;)g; &lt;span class=&quot;comment&quot;&gt;// 方法二&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;本质上，两个方法的实现是一样的，方法一的cost默认为0。那么cost时用来干什么的呢？参考&lt;a href=&quot;http://southpeak.github.io/blog/2015/02/11/cocoa-foundation-nscache/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;南峰子的技术博客&lt;/a&gt;有如下这段话：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;这个消耗值用于计算缓存中所有对象的一个消耗总和。当内存受限或者总消耗超过了限定的最大总消耗，则缓存应该开启一个丢弃过程以移除一些对象。不过，这个过程不能保证被丢弃对象的顺序。其结果是，如果我们试图操作这个消耗值来实现一些特殊的行为，则后果可能会损害我们的程序。通常情况下，这个消耗值是对象的字节大小。如果这些信息不是现成的，则我们不应该去计算它，因为这样会使增加使用缓存的成本。如果我们没有可用的值传递，则直接传递0，或者是使用-setObject:forKey:方法，这个方法不需要传入一个消耗值.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;至于其它方法嘛，都很容易理解，代理方法是NSCache在计算超过最大消耗值时，所移除的对象。&lt;/p&gt;
&lt;h3 id=&quot;NSCache代码实现&quot;&gt;&lt;a href=&quot;#NSCache代码实现&quot; class=&quot;headerlink&quot; title=&quot;NSCache代码实现&quot;&gt;&lt;/a&gt;NSCache代码实现&lt;/h3&gt;&lt;p&gt;事实上，NSCache在以前是不知道内部实现。但现在不一样了，由于Swift现在开源，我们可以通过Swift去探查NSCache的具体实现。&lt;a href=&quot;https://github.com/apple/swift-corelibs-foundation/blob/master/Foundation/NSCache.swift&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;NSCache源码&lt;/a&gt;，从源码可以看出。NSCache的底层实现，是一个双向链表。但是感觉源码存在一个bug，不知道具体是怎样子的。撇开这些bug，我们看一下关于最大的缓存内存容量和最大的缓存个数。&lt;br&gt;&lt;figure class=&quot;highlight swift&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;47&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;48&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;49&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;50&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;51&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;52&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;53&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;54&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;55&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;56&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;57&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;58&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;59&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;60&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;61&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;62&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;63&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;64&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;65&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;66&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;67&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;68&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;69&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;70&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;71&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;72&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;73&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;74&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;75&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;76&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;77&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;78&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;79&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;80&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;81&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;82&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;83&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;84&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;85&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;86&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;87&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;88&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;89&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;90&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;insert&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;number&quot;&gt;_&lt;/span&gt; entry: NSCacheEntry)&lt;/span&gt;&lt;/span&gt; &amp;#123; &lt;span class=&quot;comment&quot;&gt;// 添加缓存数据&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; _byCost == &lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        _byCost = entry&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; element = _byCost&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; e = element &amp;#123; &lt;span class=&quot;comment&quot;&gt;// 计算需要存放在链表的位置&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; e.cost &amp;gt; entry.cost &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; newPrev = e.prevByCost&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                entry.prevByCost = newPrev&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                entry.nextByCost = e &lt;span class=&quot;comment&quot;&gt;// bug，应该添加e.prevByCost = entry&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;break&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            element = e.nextByCost&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;setObject&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;number&quot;&gt;_&lt;/span&gt; obj: AnyObject, forKey key: AnyObject, cost g: Int)&lt;/span&gt;&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; keyRef = &lt;span class=&quot;built_in&quot;&gt;unsafeBitCast&lt;/span&gt;(key, to: &lt;span class=&quot;type&quot;&gt;UnsafePointer&lt;/span&gt;&amp;lt;&lt;span class=&quot;type&quot;&gt;Void&lt;/span&gt;&amp;gt;.&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;) &lt;span class=&quot;comment&quot;&gt;// 获取key的指针&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    _lock.lock()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    _totalCost += g &lt;span class=&quot;comment&quot;&gt;// 计算当前所缓存的统计&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; purgeAmount = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; totalCostLimit &amp;gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        purgeAmount = (_totalCost + g) - totalCostLimit &lt;span class=&quot;comment&quot;&gt;// 需要移除的内存大小&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; purgeCount = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; countLimit &amp;gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        purgeCount = (_entries.&lt;span class=&quot;built_in&quot;&gt;count&lt;/span&gt; + &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;) - countLimit &lt;span class=&quot;comment&quot;&gt;// 需要移除的对象个数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; entry = _entries[keyRef] &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        entry.value = obj &lt;span class=&quot;comment&quot;&gt;// 如果key已经存在，则会替换掉&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; entry.cost != g &amp;#123; &lt;span class=&quot;comment&quot;&gt;// 更新cost&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            entry.cost = g&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            remove(entry)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            insert(entry)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        _entries[keyRef] = &lt;span class=&quot;type&quot;&gt;NSCacheEntry&lt;/span&gt;(key: key, value: obj, cost: g)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    _lock.unlock() &lt;span class=&quot;comment&quot;&gt;// 解锁&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; toRemove = [&lt;span class=&quot;type&quot;&gt;NSCacheEntry&lt;/span&gt;]() &lt;span class=&quot;comment&quot;&gt;// 需要移除的对象实例&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; purgeAmount &amp;gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; &amp;#123; &lt;span class=&quot;comment&quot;&gt;// 需要丢弃缓存的数量&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        _lock.lock()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; _totalCost - totalCostLimit &amp;gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; &amp;#123; &lt;span class=&quot;comment&quot;&gt;// 由于链表有序，所以从第一个开始抛弃，直到总缓存大小小于设定的缓存大小&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; entry = _byCost &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                _totalCost -= entry.cost&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                toRemove.append(entry)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                remove(entry)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;break&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; countLimit &amp;gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            purgeCount = (_entries.&lt;span class=&quot;built_in&quot;&gt;count&lt;/span&gt; - toRemove.&lt;span class=&quot;built_in&quot;&gt;count&lt;/span&gt;) - countLimit &lt;span class=&quot;comment&quot;&gt;// 更新当前缓存的对象个数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        _lock.unlock()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; purgeCount &amp;gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        _lock.lock()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; (_entries.&lt;span class=&quot;built_in&quot;&gt;count&lt;/span&gt; - toRemove.&lt;span class=&quot;built_in&quot;&gt;count&lt;/span&gt;) - countLimit &amp;gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; &amp;#123; &lt;span class=&quot;comment&quot;&gt;// 当未超过最大缓存大小，但超过最大的缓存个数，做移除操作&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; entry = _byCost &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                _totalCost -= entry.cost&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                toRemove.append(entry)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                remove(entry)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;break&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        _lock.unlock()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; del = delegate &amp;#123; &lt;span class=&quot;comment&quot;&gt;// 代理方法，释放的对象&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; entry &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; toRemove &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            del.cache(&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;, willEvictObject: entry.value)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    _lock.lock()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; entry &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; toRemove &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        _entries.removeValue(forKey: &lt;span class=&quot;built_in&quot;&gt;unsafeBitCast&lt;/span&gt;(entry.key, to: &lt;span class=&quot;type&quot;&gt;UnsafePointer&lt;/span&gt;&amp;lt;&lt;span class=&quot;type&quot;&gt;Void&lt;/span&gt;&amp;gt;.&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;)) &lt;span class=&quot;comment&quot;&gt;// the cost list is already fixed up in the purge routines, 移除释放的对象&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    _lock.unlock()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;通过上面的代码，可以看到NSCache是按照对象容量进行排序的。在超过最大缓存设定时，是从容量从小到大的移除，这也就解决了之前不知道具体实现的而不知道移除的对象。当然，现在虽然知道移除的是谁，但是需要计算出来还是需要一定时耗的。&lt;/p&gt;
&lt;h3 id=&quot;NSCache和可变集合的区别&quot;&gt;&lt;a href=&quot;#NSCache和可变集合的区别&quot; class=&quot;headerlink&quot; title=&quot;NSCache和可变集合的区别&quot;&gt;&lt;/a&gt;NSCache和可变集合的区别&lt;/h3&gt;&lt;p&gt;接下来这段是摘抄自&lt;a href=&quot;http://southpeak.github.io/blog/2015/02/11/cocoa-foundation-nscache/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;南峰子的技术博客&lt;/a&gt;，总结的东西在很多关于NSCache的文章都可以看到。当然，还介绍各位可以看一下[Effective Objective-C 2.0 编写高质量的iOS和OS X代码的52个有效方法]&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;1.NSCache类结合了各种自动删除策略，以确保不会占用过多的系统内存。如果其它应用需要内存时，系统自动执行这些策略。当调用这些策略时，会从缓存中删除一些对象，以最大限度减少内存的占用&lt;br&gt;2.NSCache是线程安全的，我们可以在不同的线程中添加、删除和查询缓存中的对象，而不需要锁定缓存区域&lt;br&gt;3.不像NSMutableDictionary对象，一个缓存对象不会拷贝key对象&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;后记&quot;&gt;&lt;a href=&quot;#后记&quot; class=&quot;headerlink&quot; title=&quot;后记&quot;&gt;&lt;/a&gt;后记&lt;/h3&gt;&lt;p&gt;NSCache是一个很简单的缓存框架，方法简单，源代码也比较简单。通过Swift中关于NSCache的源码，可以更好的理解缓存策略。也很建议各位在学习知识点的时候，深入去学习，这样对于缓存的理解就不仅仅局限在在于调用代码的基础上。&lt;/p&gt;
&lt;p&gt;参考文献：&lt;br&gt;1.&lt;a href=&quot;http://southpeak.github.io/blog/2015/02/11/cocoa-foundation-nscache/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;南峰子的技术博客&lt;/a&gt;&lt;br&gt;2.&lt;a href=&quot;https://github.com/nixzhu/dev-blog/blob/master/2015-12-09-nscache.md&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;nixzhu/dev-blog&lt;/a&gt;&lt;br&gt;3.&lt;a href=&quot;http://www.jianshu.com/p/2fad7265317e&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;feiyangkl的简书&lt;/a&gt;&lt;br&gt;4.&lt;a href=&quot;http://nshipster.cn/nscache/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;NSCache&lt;/a&gt;&lt;br&gt;4.[Effective Objective-C 2.0 编写高质量的iOS和OS X代码的52个有效方法] Matt Galloway著 爱飞翔 译&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;说实话，最近在看SDWebImage，里面很重要的一部分就是讲缓存这个知识点。那么，写这篇文章的前半个小时，是准备写SDWebImage的源码分析的。但因为强迫症，觉得需要讲清楚缓存相关的概念，才能继续往下讲SDWebImage。因此，这篇文章，主要讲NSCache相关的知识点，以及其他方式构建缓存的优缺点。&lt;/p&gt;
    
    </summary>
    
      <category term="Foundation" scheme="http://yoursite.com/categories/Foundation/"/>
    
    
      <category term="NSCache" scheme="http://yoursite.com/tags/NSCache/"/>
    
      <category term="缓存" scheme="http://yoursite.com/tags/%E7%BC%93%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>SDWebImage 源码剖析</title>
    <link href="http://yoursite.com/2016/07/17/SDWebImage-%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"/>
    <id>http://yoursite.com/2016/07/17/SDWebImage-源码剖析/</id>
    <published>2016-07-16T16:59:11.000Z</published>
    <updated>2017-10-20T03:33:59.923Z</updated>
    
    <content type="html">&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;吐槽一下，前段时间准备面试，然后在拉勾透了各种公司，估摸着又一个月吧，得到一个面试机会。还没把握住，跪在了第四面。不知道怎么言表自己这份心情，大概有如下几个原因吧：&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;blockquote&gt;
&lt;p&gt;1.个人能力问题，这也算是最大的问题，虽然基础还过得去，但是项目经验少，知识面比较窄；&lt;br&gt;2.单纯的移动互联网威风不再，iOS市场过剩，现在都是择优录取，经验都是3－5年，我这一年的有点尴尬；&lt;br&gt;3.投递的公司，大多数是比较大型的公司，因此从项目经验和学校就给筛选掉了；&lt;br&gt;4.招聘高峰期过了，公司现在不怎么缺新人；&lt;br&gt;5.拉勾的机制问题，不知道是不是啊。上一家面试公司，那天上午给我发了面试邀请，结果下午拉勾就给我发了一条不匹配的邮件。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;然后呢，在这段时间疯狂的补基础，什么iOS基础、计算机网络、leetcode刷题、操作系统之类的。每天下班回来，就开始看各种东西。晕、晕、晕……不过投了这么久还是没有面试机会，尴尬啊。&lt;/p&gt;
&lt;p&gt;好了，吐槽完了。说一下iOS学习吧，很多时候呢，我们学完基础知识就不知道怎么深入学习了，那研究源码算是一个深入学习知识的不错选择。至于SDWebImage这个框架呢，在网上已经有很多这方面的文章了。虽然都是千篇一律，但对于没有读过源码的人来讲，看那些文章就比较吃力了。本文，也仅仅是纪录我在读SDWebImage源码时，对此框架的一些理解吧。&lt;/p&gt;
&lt;h3 id=&quot;SDWebImage解读&quot;&gt;&lt;a href=&quot;#SDWebImage解读&quot; class=&quot;headerlink&quot; title=&quot;SDWebImage解读&quot;&gt;&lt;/a&gt;SDWebImage解读&lt;/h3&gt;&lt;p&gt;SDWebImage是一个下载兼缓存的第三方常用框架，框架整体来讲分为两大块：异步下载和缓存。异步下载主要利用NSOperationQueue和NSURLSession来完成实现的，缓存分为磁盘缓存和内存缓存两种，具体的实现，会在接下来的文章中会慢慢分析。整个框架主要包含知识点有：NSOperation、NSOperationQueue、NSURLSession、GCD、NSCache和Runtime来实现的，通过categories的方式添加到我们常用的View中。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;吐槽一下，前段时间准备面试，然后在拉勾透了各种公司，估摸着又一个月吧，得到一个面试机会。还没把握住，跪在了第四面。不知道怎么言表自己这份心情，大概有如下几个原因吧：&lt;/p&gt;
    
    </summary>
    
      <category term="源码剖析" scheme="http://yoursite.com/categories/%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"/>
    
    
      <category term="源码剖析" scheme="http://yoursite.com/tags/%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"/>
    
      <category term="SDWebImage" scheme="http://yoursite.com/tags/SDWebImage/"/>
    
  </entry>
  
  <entry>
    <title>记一次面试经历</title>
    <link href="http://yoursite.com/2016/07/05/%E8%AE%B0%E4%B8%80%E6%AC%A1%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%8E%86/"/>
    <id>http://yoursite.com/2016/07/05/记一次面试经历/</id>
    <published>2016-07-05T05:55:50.000Z</published>
    <updated>2017-10-20T03:02:13.364Z</updated>
    
    <content type="html">&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;距离毕业刚好一年，那么这一年呢！换了两个公司，第一个由于内部股权争端，还没有到两个月就已经夭折（很恶心）；然后来到了第二个公司，也就是现在这个公司。在这个公司呢，待着是没啥问题，正常的编码工作，不算忙。好一点的就是能接触swift开发，算是这一年来最开心的事。问题在于，没人带，平时的相互探讨又少，工资稍低。还有个重要的原因就是：眼更瞎、腰痛、鼠标手、啤酒肚，在这一年内都一一发生了（看来应该买本《程序员健康指南》）,这些谋生了我想离开本公司的想法。所以，在上个月就开始准备去面试。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;在拉勾投了半个月，然后收到了一份面试邀请。第一个星期的简历写的太简单，当然第二份也差不多。在面试完才发现，其实在这一年做过的项目是没有什么技术深度的。所以，导致投了很多简历都没人给机会。所以，非常感谢给机会面试的这家公司&lt;a href=&quot;https://www.futu5.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;富途&lt;/a&gt;，公司大多数都是腾讯出来的员工，也拿到了腾讯的投资，非常不错的一家公司。&lt;/p&gt;
&lt;h3 id=&quot;面试过程&quot;&gt;&lt;a href=&quot;#面试过程&quot; class=&quot;headerlink&quot; title=&quot;面试过程&quot;&gt;&lt;/a&gt;面试过程&lt;/h3&gt;&lt;p&gt;面试时间是7.4号，由于之前预约的是15点面试，所以早上我从珠海赶车去深圳。到了深圳吃完饭，差不多14:20，也没事做就早点到了公司。进门的感受挺不错，和前台沟通了一下。然后，就等着面试官开始面试。&lt;/p&gt;
&lt;h4 id=&quot;一面&quot;&gt;&lt;a href=&quot;#一面&quot; class=&quot;headerlink&quot; title=&quot;一面&quot;&gt;&lt;/a&gt;一面&lt;/h4&gt;&lt;p&gt;基本上的面试流程都是先自我介绍，介绍完之后，就开始针对简历中的项目开始提问。首先，根据我的项目开始问项目遇到的技术难点、是否有看过第三方框架的源码、GCD等。待我回答完之后，可以从他的表情和言语中看出，表现的不是特别好（很差）。然后，在看到我的简历写了关于我在学校学过一些算法，就拿了一份试题给我做。试题内容是关于：指针、字节对齐、数据库等问题；还有4道手写代码題（具体的不能透露，因为公司花了很多时间在这个上面），建议面试可以看&lt;a href=&quot;http://blog.csdn.net/v_JULY_v&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;算法之道 结构之法&lt;/a&gt;的博客，也可以访问&lt;a href=&quot;https://www.julyedu.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;7月在线&lt;/a&gt;，博主现在开始创业，所以可以支持下。庆幸的是，自己还没忘记当时学过的知识，大部分都是自己遇到的，也很快得出了结果。当然，也有一些小问题错了，在面试官的指引下逐步完成了最后的代码。&lt;/p&gt;
&lt;p&gt;那么在算法这块，自我感觉还算好，毕竟曾今奋斗的东西，虽然并没有取得好的成果。在面试中，和面试官沟通的也很顺畅，面了应该有1个小时吧（当时没怎么看手机）。面试完之后，面试官给出了两个职位iMac开发、iOS开发，问我是不是只做iOS开发。这个嘛，当然不是啊，多学一门技艺总是不错的，恰好有机会，那么不会那么倔强。接着，问我有没有什么要了解的。我大概说了下，自己从学iOS之后开始就是一直自学的，即使在现在这家公司，也没怎么和leader深入探讨iOS相关的属性已经深入的知识等（小公司的悲哀，能做出效果就可以了）。面试官也很用心的给我介绍了，关于公司团队的发展和培养，简而言之就是有人带，每一两周有分享会或者review。很明显，这是符合我的要求。&lt;/p&gt;
&lt;p&gt;然后，面试官让我等第二位面试官来面试。隐约可以看出，这应该是iOS的主管。&lt;/p&gt;
&lt;h4 id=&quot;二面&quot;&gt;&lt;a href=&quot;#二面&quot; class=&quot;headerlink&quot; title=&quot;二面&quot;&gt;&lt;/a&gt;二面&lt;/h4&gt;&lt;p&gt;这轮面试和第一轮面试差不多，简单介绍自己，稍微问了下项目的东西，应该和一面面试官说了下我的情况（iOS不算很好，算法还过得去）。然后拿了一份逻辑题（一张图，找出其中的重要信息，并回答问题）给我做，大概5分钟。一开始有点懵逼，但细下心来还是可以抽离出其中的重要信息，错了两道（一题是看漏重要信息，另外一题是有点争议吧，个人觉得）。探讨的过程中，讲述了原因，证明这并是不猜的。&lt;/p&gt;
&lt;p&gt;这份逻辑题，主要考察观察能力和逻辑思维能力。至于，在实际的项目中有没有帮助呢？那就见仁见智了（同样，不会给出那种图，见谅）。接着，这轮面试官也给了份面试题，主要包括：数学概率、数据结构、操作系统、计算机网络、数据库和一道数独。由于，很久没有接触过上面的这些问题，有几道题就比较犹豫。至于数独嘛，我平时就喜欢玩这个，自然不会有太大问题。&lt;/p&gt;
&lt;p&gt;最后，和面试官讨论了关于几道错误题目的问题。有一些，可能是忘了概念，然后做错。有一些，是直接就忘记只是点了。不过，沟通起来还算可以。&lt;/p&gt;
&lt;h4 id=&quot;三面&quot;&gt;&lt;a href=&quot;#三面&quot; class=&quot;headerlink&quot; title=&quot;三面&quot;&gt;&lt;/a&gt;三面&lt;/h4&gt;&lt;p&gt;三面是CTO面试，由于二面时，面试官去开会了，花了比较长的时间。CTO面也是等了比较久，不过还算好（CTO都比较忙，能抽出的时间不多），在HR、一面面试官和CTO协商下，决定面试完毕。等了一段时间，HR带领我去CTO办公司，这期间，比较开心的是一面面试官拿了一些面包给我，非常 nice。到了CTO办公室，又是一次自我介绍。然后，问了一些平时不会遇到的问题。具体的知识点如下（还是不会说原题）：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;第一题：for的不同形式实现；&lt;br&gt;第二题：宏定义&lt;br&gt;第三题：概率&lt;br&gt;第四题：某个算法&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;对于第一个问题，花了比较长的时间，总是怀疑自己会不会for循环。感觉自己没有问题，CTO每次看了之后，都说有问题再改。最后，在梳理for循环执行的顺序的时候，面试官的语句话提醒了自己，真是一语惊醒梦中人，当头一喝。好吧，还是自己坑，此时感觉不妙，有点悬了。&lt;br&gt;第二题宏定义，也花了很多时间。宏定义在使用的时候，是替换原有的代码。而不是拿宏定义内部的结果去做计算，在编码的过程中是很值得注意的。那么扩展阅读：const、#import和#define的区别&lt;br&gt;第三题，花了比较长的时间，改改改，数学概率题。&lt;br&gt;第四题算法题，这个嘛，讲思想，遇到了就知道。&lt;/p&gt;
&lt;p&gt;整个CTO面试的过程都是懵的，从第一个问题开始，CTO的安静和一眼抓住重要点的气场让我真心hold不住。不过，在CTO面试结束之后，和一面面试官聊天的时候说CTO是个非常厉害的人。好吧，也算感受到技术大拿的气场了。在上面的问题问完之后，主要了解了一下怎么学习知识，在哪学习和掌握的技能，这些问题也因为前面的问题受到影响而没有怎么回答好。感觉更加悬了，心头坠了一块石头，拉不上去，掉不下来。&lt;/p&gt;
&lt;p&gt;面试完毕已经19:30了，好吧，带着一脸忐忑的心和懵逼的脸，涌进在川流不息的人流中，消失在璀璨的霓虹灯的喧嚣世界里……&lt;/p&gt;
&lt;h3 id=&quot;总结&quot;&gt;&lt;a href=&quot;#总结&quot; class=&quot;headerlink&quot; title=&quot;总结&quot;&gt;&lt;/a&gt;总结&lt;/h3&gt;&lt;p&gt;整个面试过程，可以发现iOS的基础掌握不够，学习的知识深度不够。仅仅停留在调用API的层面，没有深入了解iOS的技术等。对于基础的算法、数据结构、计算机网络和操作系统的知识忘的比较快。没有怎么去复习，这个算是一大弊端。不过，通过这次面试，可以知晓自己的技术停留的阶段，在深入学习的道路上，知道自己应该弥补的方向。好了，最后，不管有没有offer，就算是一次检视自己的经历吧。&lt;/p&gt;
&lt;h3 id=&quot;安利&quot;&gt;&lt;a href=&quot;#安利&quot; class=&quot;headerlink&quot; title=&quot;安利&quot;&gt;&lt;/a&gt;安利&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;我们的生命，有的时候会是泥沙，你可能慢慢地就会像泥沙一样，沉淀下去了，一旦你沉淀下去了，也许你不用再为了前进而努力了，但是你却永远见不到阳光了。所以我建议大家，不管你现在的生命是怎样的，一定要有水的精神，像水一样不断的积蓄自己地力量，不断的冲破障碍，当你发现时机不到的和时候，把自己的厚度给积累起来，当有一天时机来临的时候，你就能够奔腾入海，成就自己的生命！ – 俞敏洪《赢在中国》&lt;/p&gt;
&lt;/blockquote&gt;
</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;距离毕业刚好一年，那么这一年呢！换了两个公司，第一个由于内部股权争端，还没有到两个月就已经夭折（很恶心）；然后来到了第二个公司，也就是现在这个公司。在这个公司呢，待着是没啥问题，正常的编码工作，不算忙。好一点的就是能接触swift开发，算是这一年来最开心的事。问题在于，没人带，平时的相互探讨又少，工资稍低。还有个重要的原因就是：眼更瞎、腰痛、鼠标手、啤酒肚，在这一年内都一一发生了（看来应该买本《程序员健康指南》）,这些谋生了我想离开本公司的想法。所以，在上个月就开始准备去面试。&lt;/p&gt;
    
    </summary>
    
      <category term="面试经历" scheme="http://yoursite.com/categories/%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%8E%86/"/>
    
    
      <category term="经历" scheme="http://yoursite.com/tags/%E7%BB%8F%E5%8E%86/"/>
    
  </entry>
  
  <entry>
    <title>iOS之weak-strong dance</title>
    <link href="http://yoursite.com/2016/07/05/iOS%E4%B9%8Bweak-strong-dance/"/>
    <id>http://yoursite.com/2016/07/05/iOS之weak-strong-dance/</id>
    <published>2016-07-05T05:30:27.000Z</published>
    <updated>2016-07-05T05:53:41.000Z</updated>
    
    <content type="html">&lt;p&gt;&lt;a href=&quot;http://www.jianshu.com/p/0f28c1bead3e&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;weak-strong dance&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://sherlockyao.com/blog/2015/08/08/weakself-and-strongself-in-blocks/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;weak-strong dance&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://www.jianshu.com/p/0f28c1bead3e&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;weak-strong dance&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://sherlockyao.com/b
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>学习资料汇总</title>
    <link href="http://yoursite.com/2016/07/01/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99%E6%B1%87%E6%80%BB/"/>
    <id>http://yoursite.com/2016/07/01/学习资料汇总/</id>
    <published>2016-07-01T07:12:25.000Z</published>
    <updated>2016-07-05T05:21:04.000Z</updated>
    
    <content type="html">&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;归属&lt;/th&gt;
&lt;th&gt;博客&lt;/th&gt;
&lt;th&gt;添加时间&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Swift&lt;/td&gt;
&lt;td&gt;&lt;a href=&quot;https://github.com/linkedin/swift-style-guide&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;LinkedIn Swift Style Guide&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;2016-7-1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;iOS面试心经&lt;/td&gt;
&lt;td&gt;&lt;a href=&quot;https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01%E3%80%8A%E6%8B%9B%E8%81%98%E4%B8%80%E4%B8%AA%E9%9D%A0%E8%B0%B1%E7%9A%84iOS%E3%80%8B%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%82%E8%80%83%E7%AD%94%E6%A1%88/%E3%80%8A%E6%8B%9B%E8%81%98%E4%B8%80%E4%B8%AA%E9%9D%A0%E8%B0%B1%E7%9A%84iOS%E3%80%8B%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%82%E8%80%83%E7%AD%94%E6%A1%88%EF%BC%88%E4%B8%8A%EF%BC%89.md&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;招聘一个靠谱的 iOS&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;2016-7-5&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
</content>
    
    <summary type="html">
    
      &lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;归属&lt;/th&gt;
&lt;th&gt;博客&lt;/th&gt;
&lt;th&gt;添加时间&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Swift&lt;/td&gt;
&lt;td&gt;&lt;a href=&quot;https://github.com/linked
    
    </summary>
    
      <category term="学习资料" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/"/>
    
    
      <category term="学习资料" scheme="http://yoursite.com/tags/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/"/>
    
      <category term="技术博客" scheme="http://yoursite.com/tags/%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title>关于单例模式的思考</title>
    <link href="http://yoursite.com/2016/06/29/%E5%85%B3%E4%BA%8E%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%9A%84%E6%80%9D%E8%80%83/"/>
    <id>http://yoursite.com/2016/06/29/关于单例模式的思考/</id>
    <published>2016-06-29T12:56:36.000Z</published>
    <updated>2017-10-20T03:01:57.836Z</updated>
    
    <content type="html">&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;一直以来呢，对于设计模式感觉就是非常神奇的一个东西。从网上开始搜索一些关于设计模式的教程来学习，不过说真的，仅仅是自己通过网络的资料来学习是非常蛋疼的一件事。因为，没有人指导，感觉就是知其然，不知其所以然，就例如接下来要写的单例模式的猜想。那么，今天要解决什么问题呢？有如下三点：&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;blockquote&gt;
&lt;p&gt;1.由于单例模式在内存中的生命周期是当第一次使用的时候开始创建，直到application应用销毁时，才从内存中移除。那么问题在于，单例对象在内存中创建之后，所占的内存大小是多少呢？&lt;br&gt;2.在单例方法中，使用多线程，对单例中属性的影响？&lt;br&gt;3.在那些条件下使用单例、实例及类方法？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;单例模式&quot;&gt;&lt;a href=&quot;#单例模式&quot; class=&quot;headerlink&quot; title=&quot;单例模式&quot;&gt;&lt;/a&gt;单例模式&lt;/h3&gt;&lt;p&gt;简单说一下单例模式吧（万年不变的梗，百度一堆一样的），算了还是不要讲单例模式了，直接放几个对单例模式讲解不错的博客：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt; &lt;a href=&quot;http://www.jianshu.com/p/4130096cee03&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;华山论剑之浅谈iOS单例对象&lt;/a&gt;&lt;br&gt; &lt;a href=&quot;https://segmentfault.com/a/1190000003941840&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;iOS中单例模式&lt;/a&gt;&lt;br&gt; &lt;a href=&quot;http://shaynechow.github.io/iOS-Singleton/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;iOS单例模式&lt;/a&gt;&lt;br&gt; &lt;a href=&quot;http://www.jianshu.com/p/7486ebfcd93b&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;iOS之单例模式初探&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;单例模式猜想求证&quot;&gt;&lt;a href=&quot;#单例模式猜想求证&quot; class=&quot;headerlink&quot; title=&quot;单例模式猜想求证&quot;&gt;&lt;/a&gt;单例模式猜想求证&lt;/h3&gt;&lt;p&gt;上面的博客，大体上能讲清楚单例模式，以及单例模式的创建等问题。那么，回到文章的开始，我们提到的几个问题。&lt;/p&gt;
&lt;p&gt;看个例子，主要是解决这三个问题的简单例子&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt; 开发环境: Xcode 7.3&lt;br&gt; 开发语言: Swift 2.2, Objective-C&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;示例代码如下：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;47&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;48&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;49&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;50&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;51&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;52&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;53&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;54&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;55&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;56&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;57&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;58&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;59&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;60&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;61&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;62&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;63&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;64&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;65&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;66&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;67&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;68&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;69&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;70&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;71&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;72&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;73&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;74&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;// SYObject.h&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@interface SYObject : NSObject&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+ (SYObject *)shareInstance;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (size_t)calculateInstanceSize;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (size_t)calculateInstanceSize2;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (void)getInstanceIvar;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@property (nonatomic, assign) long longValue;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@property (nonatomic, assign) BOOL isFailure;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;////@property (nonatomic, assign) int value;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;////@property (nonatomic, assign) short shortValue;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@end&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// SYObject.m&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#import &amp;quot;SYObject.h&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#import &amp;lt;malloc/malloc.h&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#import &amp;lt;objc/runtime.h&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@implementation SYObject&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+ (SYObject *)shareInstance &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    static SYObject *instance;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    static dispatch_once_t token;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    dispatch_once(&amp;amp;token, ^&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        instance = [[self alloc] init];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return instance;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 计算实例大小&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (size_t)calculateInstanceSize &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    size_t size = malloc_size((__bridge const void *)([SYObject shareInstance]));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return size;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 计算实例大小&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (size_t)calculateInstanceSize2 &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    size_t size = size = class_getInstanceSize([SYObject class]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return size;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 获取ivars&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (void)getInstanceIvar &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    unsigned int count = 0;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Class cls = [SYObject class];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Ivar *ivars = class_copyIvarList(cls, &amp;amp;count);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    for (int i = 0; i &amp;lt; count; i++) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        Ivar *ivar = &amp;amp;ivars[i];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        NSLog(@&amp;quot;instance variable&amp;apos;s name: %s at index: %d&amp;quot;, ivar_getName(*ivar), i);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 调用&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;let instance = SYObject.shareInstance()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;var count = instance.calculateInstanceSize()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;print(count)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;count = instance.calculateInstanceSize2()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;instance.getInstanceIvar()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;print(count)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Sample Output:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;molloc instance size: 32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;get instance size: 24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2016-06-30 00:47:27.591 SYMultipleThread[78991:1216822] instance variable&amp;apos;s name: _isFailure at index: 0&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2016-06-30 00:47:27.591 SYMultipleThread[78991:1216822] instance variable&amp;apos;s name: _isSuccess at index: 1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;首先解决第一个问题：单例模式自创建之后，在内存中所占的大小是多少？从上面的例子中，我们容易看出结果，通过我们添加修改属性和私有属性等参数，然后就可以得到单例在内存中最终的结果。&lt;/p&gt;
&lt;p&gt;从上面，我们还发现另外两个问题：1.为何两次方法调用的结果不一样？2.计算的结果不是各个类型字节大小之和嘛？&lt;br&gt;第1个问题，在于iOS分配内存时，小于16字节的内存，会直接分配16字节，是在一定程度上提高了存储效率。所以，第一个方法是iOS分配内存的大小，第二个方法则是实际对象所占的内存空间大小。&lt;br&gt;第2个问题，为何不一样？&lt;strong&gt;&lt;a href=&quot;http://www.cnblogs.com/clover-toeic/p/3853132.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;字节对齐&lt;/a&gt;&lt;/strong&gt;，至于什么是字节对齐，就不再展开了。但发现一个问题，就是说iOS会根据我们定义的属性大小自己去分配最小的内存空间（如果没有实验错误的话，C语言中的结构体就不会，所以C做内存优化的时候，可以针对结构体中的变量位置做优化）。&lt;/p&gt;
&lt;p&gt;第二个问题的示例代码：&lt;br&gt;&lt;figure class=&quot;highlight swift&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;SYThreadModel&lt;/span&gt;: &lt;span class=&quot;title&quot;&gt;NSObject&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; a = &lt;span class=&quot;string&quot;&gt;&quot;&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; b = &lt;span class=&quot;string&quot;&gt;&quot;&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;shareInstance&lt;/span&gt;() -&amp;gt; &lt;span class=&quot;title&quot;&gt;SYThreadModel&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Static&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; token: dispatch_once_t = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; instance: &lt;span class=&quot;type&quot;&gt;SYThreadModel&lt;/span&gt;? = &lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        dispatch_once(&amp;amp;&lt;span class=&quot;type&quot;&gt;Static&lt;/span&gt;.token) &amp;#123; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;type&quot;&gt;Static&lt;/span&gt;.instance = &lt;span class=&quot;type&quot;&gt;SYThreadModel&lt;/span&gt;()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;Static&lt;/span&gt;.instance!&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;setValue&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(str: String, ch: String)&lt;/span&gt;&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; queue = dispatch_get_global_queue(&lt;span class=&quot;type&quot;&gt;DISPATCH_QUEUE_PRIORITY_DEFAULT&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        dispatch_async(queue) &amp;#123; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;type&quot;&gt;SYThreadModel&lt;/span&gt;.shareInstance().a = str&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;type&quot;&gt;NSThread&lt;/span&gt;.sleepForTimeInterval(&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;type&quot;&gt;SYThreadModel&lt;/span&gt;.shareInstance().b = ch&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;built_in&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;&lt;span class=&quot;subst&quot;&gt;\(SYThreadModel.shareInstance()&lt;/span&gt;.a) == &lt;span class=&quot;subst&quot;&gt;\(SYThreadModel.shareInstance()&lt;/span&gt;.b)&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 调用&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; instance = &lt;span class=&quot;type&quot;&gt;SYThreadModel&lt;/span&gt;.shareInstance()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;instance.setValue(&lt;span class=&quot;string&quot;&gt;&quot;a&quot;&lt;/span&gt;, ch: &lt;span class=&quot;string&quot;&gt;&quot;b&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;instance.setValue(&lt;span class=&quot;string&quot;&gt;&quot;c&quot;&lt;/span&gt;, ch: &lt;span class=&quot;string&quot;&gt;&quot;d&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// Sample Output&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;c&lt;/span&gt; == b&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;c&lt;/span&gt; == b&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;如上面代码，我们可以看到，这并不是我们想要的结果。那么，问题在于为何会出现这样的问题呢？这就归咎到dispatch_async()，由于在执行过程中，dispatch_async是并行执行，因此谁都有可能改变a或b的值。这也就使得在多线程使用单例会让数据变的很不安全。&lt;/p&gt;
&lt;p&gt;第三个问题：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt; 单例：使用单例仅仅是保证该类在整个生命周期只会存在一块内存空间，在一定程度上降低了内存空间的开销；&lt;br&gt; 实例：实例是保证数据的隔离，互相不冲突，通常情况下，我们都会选择使用实例对象；&lt;br&gt; 类方法：也称静态方法，它的生命周期，只存在于调用该方法开始，直到该方法执行结束，这是类方法里面开辟的内存空间就会被销毁。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;通过，对三种方法的简单描述，然后自己思考，在具体的项目中应该如何去使用。&lt;/p&gt;
&lt;h3 id=&quot;后记&quot;&gt;&lt;a href=&quot;#后记&quot; class=&quot;headerlink&quot; title=&quot;后记&quot;&gt;&lt;/a&gt;后记&lt;/h3&gt;&lt;p&gt;最后，总结一下：单例模式在一定程度上，控制实例个数，节省系统资源；但同样也会使得系统数据变的冗余，（例如：某个类我们只需要使用一次，之后就再也不使用了，如果使用单例，它的生命周期和系统的生命周期是一样的，释放不掉，由此增加了数据的冗余）；尽量不在使用多线程去修改单例属性，否则就像第二个问题一样，使得数据并不安全。因此，在最后的最后，在写代码的过程中，使用好单例模式，切勿滥用，否则出现的后果就非常麻烦。&lt;/p&gt;
&lt;h3 id=&quot;推荐阅读&quot;&gt;&lt;a href=&quot;#推荐阅读&quot; class=&quot;headerlink&quot; title=&quot;推荐阅读&quot;&gt;&lt;/a&gt;推荐阅读&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;http://objccn.io/issue-13-2/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;避免滥用单例&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;一直以来呢，对于设计模式感觉就是非常神奇的一个东西。从网上开始搜索一些关于设计模式的教程来学习，不过说真的，仅仅是自己通过网络的资料来学习是非常蛋疼的一件事。因为，没有人指导，感觉就是知其然，不知其所以然，就例如接下来要写的单例模式的猜想。那么，今天要解决什么问题呢？有如下三点：&lt;/p&gt;
    
    </summary>
    
      <category term="设计模式" scheme="http://yoursite.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
      <category term="设计模式" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="单例" scheme="http://yoursite.com/tags/%E5%8D%95%E4%BE%8B/"/>
    
  </entry>
  
  <entry>
    <title>简历.杨森.iOS开发工程师</title>
    <link href="http://yoursite.com/2016/06/29/%E7%AE%80%E5%8E%86-%E6%9D%A8%E6%A3%AE-iOS%E5%BC%80%E5%8F%91%E5%B7%A5%E7%A8%8B%E5%B8%88/"/>
    <id>http://yoursite.com/2016/06/29/简历-杨森-iOS开发工程师/</id>
    <published>2016-06-29T05:25:18.000Z</published>
    <updated>2017-10-20T03:03:07.434Z</updated>
    
    <content type="html">&lt;h3 id=&quot;基本资料&quot;&gt;&lt;a href=&quot;#基本资料&quot; class=&quot;headerlink&quot; title=&quot;基本资料&quot;&gt;&lt;/a&gt;基本资料&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt; 姓   名：杨森&lt;br&gt; 联系电话：13726213088&lt;br&gt; 邮   箱：735003861@qq.com, seninchina@gmail.com&lt;br&gt; 博   客：blog.ysenin.com&lt;br&gt; 应聘职位：iOS开发工程师&lt;br&gt; 工作经验：3年工作&lt;/p&gt;
&lt;/blockquote&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;教育背景&quot;&gt;&lt;a href=&quot;#教育背景&quot; class=&quot;headerlink&quot; title=&quot;教育背景&quot;&gt;&lt;/a&gt;教育背景&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt; 毕业院校：北京理工大学珠海学院&lt;br&gt; 专   业：软件工程&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;荣誉及获奖情况&quot;&gt;&lt;a href=&quot;#荣誉及获奖情况&quot; class=&quot;headerlink&quot; title=&quot;荣誉及获奖情况&quot;&gt;&lt;/a&gt;荣誉及获奖情况&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt; 程序基础设计协会负责人以及协会培训主讲人&lt;br&gt; 2013广东省ACM-ICPC优胜奖&lt;br&gt; 多次校内算法比赛获奖&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;技能&quot;&gt;&lt;a href=&quot;#技能&quot; class=&quot;headerlink&quot; title=&quot;技能&quot;&gt;&lt;/a&gt;技能&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt; 熟练掌握Swift开发语言&lt;br&gt; 熟练代码实现UI编写&lt;br&gt; 熟练掌握MVC架构&lt;br&gt; 基本掌握Autolayout、Masony、Xib布局&lt;br&gt; 基本掌握Objective-C开发语言&lt;br&gt; 基本掌握AVFoundation、UIKit、Foundation等系统框架&lt;br&gt; 基本掌握AFNetworking、FMDB、MBProgressHUD等第三方框架&lt;br&gt; 了解内存管理、block、GCD等多线程技术的使用&lt;br&gt; 初步了解Objective-C的runtime机制、MVVM架构、ReactiveCocoa响应式编程&lt;br&gt; 使用sqlite做数据持久化、Swift与Objective-C混编、Swift语言更新的经历等&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;项目经验&quot;&gt;&lt;a href=&quot;#项目经验&quot; class=&quot;headerlink&quot; title=&quot;项目经验&quot;&gt;&lt;/a&gt;项目经验&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt; &lt;strong&gt;珠海轼域网络科技  Mieah邮件客户端 iOS端 Swift2.2（2015.10 - 2016.7）&lt;/strong&gt;&lt;br&gt; 简述：&lt;br&gt;      获取Gmail API，获取邮件数据并解析，通过联系人，实现群组功能。用户可以使用客户端发送个人邮件、多人邮件以及群组邮件等功能。&lt;/p&gt;
&lt;p&gt; 工作内容：&lt;br&gt;      1.接入Gmail API，解析邮件数据，获取用户和联系人的数据，发送邮件及附件；&lt;br&gt;      2.Mieah项目的UI以及逻辑实现（对话、广告邮件、联系人、设定）；&lt;br&gt;      3.创建群组、分析多人邮件、添加联系人（输入email、手机联系人）等功能实现；&lt;br&gt;      4.通过AFNetworking框架实现客户端与服务器的数据交互；&lt;br&gt;      5.通过sqlite和NSUserDefault实现数据持久化处理；&lt;br&gt;      6.通过AVFoundation系统框架实现音频录制与播放、视频录制裁剪与播放、二维码扫描与解析；&lt;br&gt;      7.读写沙盒数据以及系统相册数据等；&lt;br&gt;      8.网络请求、内存使用调优。&lt;/p&gt;
&lt;p&gt; 难点：&lt;br&gt;      邮件内容截取、附件数据下载及展示、群组功能数据与后台的交互等。&lt;/p&gt;
&lt;p&gt; &lt;strong&gt;珠海轼域网络科技  skillTemp iOS端 Swift2.0（2015.8 - 2015.10）&lt;/strong&gt;&lt;br&gt; 简述：&lt;br&gt;      一款类似于italk的技能交易平台，用户将自己拥有的专业技能（洗剪吹，教育技能等）放到平台供需求用户浏览，也可以寻求自己需要的技能，并与该对象达成沟通交易。目前在香港App Store上架。&lt;/p&gt;
&lt;p&gt; 工作内容：&lt;br&gt;      1.Facebook数据、分享、点赞；&lt;br&gt;      2.登陆密码加密形式与后台交互；&lt;br&gt;      3.用户协议及隐私的UI和逻辑处理；&lt;br&gt;      4.修改第三方图片浏览器，在图片放大时，出现缩放错误Bug修复；&lt;br&gt;      5.个人资料的显示UI以及逻辑修改；&lt;br&gt;      6.用户对话界面的语音发送、UI和逻辑编写；&lt;br&gt;      7.用户联系人的有序逻辑显示；&lt;br&gt;      8.简单的Google Map和iPhone内置地图的切换显示标注等逻辑；&lt;br&gt;      9.Swift升级带来的问题修复。&lt;/p&gt;
&lt;p&gt; 难点：&lt;br&gt;      Swift语言升级时修改API和修改skillTemp的逻辑Bug。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;个人项目&quot;&gt;&lt;a href=&quot;#个人项目&quot; class=&quot;headerlink&quot; title=&quot;个人项目&quot;&gt;&lt;/a&gt;个人项目&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt; &lt;strong&gt;C语言教学辅助系统 iOS端 Objective-C(学校老师带领的项目)&lt;/strong&gt;&lt;br&gt; 简述：结合教学大纲，制定不同练习模式的教学辅助的应用。&lt;br&gt; 内容：制定练习模式，完成编码实现。&lt;br&gt; 难点：Objective-C语言学习&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;其他&quot;&gt;&lt;a href=&quot;#其他&quot; class=&quot;headerlink&quot; title=&quot;其他&quot;&gt;&lt;/a&gt;其他&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt; 喜欢思考，喜欢与人交谈&lt;br&gt; 爱看美剧&lt;br&gt; 在杭电ACM刷题（大学），leetcode刷题（付费的太贵，只能看）&lt;/p&gt;
&lt;/blockquote&gt;
</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;基本资料&quot;&gt;&lt;a href=&quot;#基本资料&quot; class=&quot;headerlink&quot; title=&quot;基本资料&quot;&gt;&lt;/a&gt;基本资料&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt; 姓   名：杨森&lt;br&gt; 联系电话：13726213088&lt;br&gt; 邮   箱：735003861@qq.com, seninchina@gmail.com&lt;br&gt; 博   客：blog.ysenin.com&lt;br&gt; 应聘职位：iOS开发工程师&lt;br&gt; 工作经验：3年工作&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="简历" scheme="http://yoursite.com/categories/%E7%AE%80%E5%8E%86/"/>
    
    
      <category term="简历" scheme="http://yoursite.com/tags/%E7%AE%80%E5%8E%86/"/>
    
  </entry>
  
  <entry>
    <title>多线程系列之GCD之一</title>
    <link href="http://yoursite.com/2016/06/25/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%B3%BB%E5%88%97%E4%B9%8BGCD/"/>
    <id>http://yoursite.com/2016/06/25/多线程系列之GCD/</id>
    <published>2016-06-25T08:45:34.000Z</published>
    <updated>2017-10-20T02:54:52.328Z</updated>
    
    <content type="html">&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;网上关于多线程的文章已经烂大街了，问题是为啥我还要继续写呢？没有为啥，单纯想写。看到有些文章空泛的描述出使用的什么方法来生成多线程，然后就扔一堆代码，这种做法真是令人作呕，至少我是这么觉得的。好吧，调侃的差不多了，也来写写自己对于多线程的理解，那么这一片会首先介绍GCD。文章主要参考[Objective-C高级编程、iOS与OS X多线程和内存指南]，一本很不错的书。算了还是不要说参考了，摘抄。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;blockquote&gt;
&lt;p&gt;示例代码语言：Swift 2.2&lt;br&gt;Xcode版本: Xcode 7.3&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;那么首先说，什么是GCD呢？按照苹果的官方解释说：GCD(Grand Central Dispatch)是异步执行技术的技术之一。一般将应用程序中技术的线程管理用的代码在系统中实现。开发者只需要定义想执行的任务追加到适当的Dispatch Queue中，GCD生成必要的线程并计划执行任务。由于线程管理是作为系统的一部分来实现的，因此可统一管理，也可执行任务，这样就比之前的线程更有效率（摘自上面提到的参考书，参考书又参考值苹果官方文档，现在沦为文字的搬运工了，呵呵哒）。&lt;br&gt;简单的来讲，就是说我们GCD的API，然后将我们需要执行的处理写在block中，然后把block追加到GCD的队列就可以了，GCD会自己去规划并生成线程进行处理。&lt;/p&gt;
&lt;h3 id=&quot;线程&quot;&gt;&lt;a href=&quot;#线程&quot; class=&quot;headerlink&quot; title=&quot;线程&quot;&gt;&lt;/a&gt;线程&lt;/h3&gt;&lt;p&gt;按照wikipedia中的描述是：线程是操作系统能够进行运算调度的最小单位，它被包含在进程中……线程分为两种，同步与非同步（异步）。同步是在本线程中执行，异步则是开辟新的线程执行。在项目中，适当的使用两者会让整个项目的性能得到很大的提升。虽然在使用多线程时，会遇到很多问题，学会处理多线程带来的问题，及时避免就不会出现太大的问题。&lt;/p&gt;
&lt;h4 id=&quot;同步&quot;&gt;&lt;a href=&quot;#同步&quot; class=&quot;headerlink&quot; title=&quot;同步&quot;&gt;&lt;/a&gt;同步&lt;/h4&gt;&lt;p&gt;针对于同步线程来讲，在添加任务到同步线程队列中，只有等前一个任务完成之后，后一个任务才能继续执行。大概意思和队列是一样的，先进先出的原则，正如一条单行线。代码如下：&lt;br&gt;&lt;figure class=&quot;highlight swift&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;同步线程执行开始&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; queue = dispatch_queue_create(&lt;span class=&quot;string&quot;&gt;&quot;com.ysenin.symultiplethread&quot;&lt;/span&gt;, &lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;dispatch_sync(queue) &amp;#123; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;同步线程执行中&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;同步线程执行完毕&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;上面这段代码呢，执行结果为：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;同步线程执行开始&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;同步线程执行中&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;同步线程执行完毕&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;此时需要注意很重要的一点，真的很重要的一点。如果把上面的queue换成dispatch_get_main_queue()呢？这个又会怎样呢？结果只会输出：“同步线程执行开始”。这是为什么呢？如下：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;死锁&lt;/strong&gt;&lt;br&gt;在调用dispatch_sync(queue)时，需要将线程阻塞，此时是主线程；&lt;br&gt;同步派发sync导致block需要在主线程中执行结束后才会返回；&lt;br&gt;而此时主线程被阻塞，两者相互等待，线程出现死锁。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;同样，Serial Dispatch Queue中，也会出现类似的情况，代码如下：&lt;br&gt;&lt;figure class=&quot;highlight swift&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;线程执行开始&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;queue = dispatch_queue_create(&lt;span class=&quot;string&quot;&gt;&quot;com.ysenin.symultiplethread&quot;&lt;/span&gt;, &lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; i &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;..&amp;lt;&lt;span class=&quot;number&quot;&gt;1000&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    dispatch_async(queue, &amp;#123; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        dispatch_sync(queue, &amp;#123; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;built_in&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;线程执行中: &lt;span class=&quot;subst&quot;&gt;\(i)&lt;/span&gt;&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;线程执行完毕&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;代码执行的结果为:”线程执行开始”,当然此时代码页面不会阻塞主线程，而仅仅是queue中的派发的线程会阻塞。至于什么事Serial Dispatch Queue，在接下来的部分会讲到。所以，如果在主线程派发队列或者Serial Dispatch Queue中就需要避免上面出现的问题，否则代码写完半天，不出结果，那就比较恶心了。&lt;/p&gt;
&lt;h4 id=&quot;异步&quot;&gt;&lt;a href=&quot;#异步&quot; class=&quot;headerlink&quot; title=&quot;异步&quot;&gt;&lt;/a&gt;异步&lt;/h4&gt;&lt;p&gt;上面简单的讲了同步，接下来讲讲异步。异步在我们项目中可是经常遇到的问题，譬如网络数据加载，动画的长时间绘制和大文件处理等。由于我们现在所用到的设备大部分已经不是单核设备，都已经升级为多核，那么对于多核来讲，意味着线程变多，处理变快。随着线程变的多，也就出现了不同的问题。在使用多线程过程中，容易出现一下问题：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;1.数据竞争（两个或者多个线程，更新同一条数据）&lt;br&gt;2.死锁（两个线程相互指向对方）&lt;br&gt;3.大量线程导师消耗大量内存（大量开辟线程）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;当然，解决上述问题的方法会很多，虽然有点难，比起出现的概率和性能的提升，这点难点都不足以阻碍使用GCD。&lt;/p&gt;
&lt;p&gt;异步的源代码如下所示：&lt;br&gt;&lt;figure class=&quot;highlight swift&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;dispatch_async(queue, &amp;#123; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 想要执行的任务&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;异步执行处理包涵两种队列: Serial Dispatch Queue、Concurrent Dispatch Queue。&lt;br&gt;| Dispatch Queue的种类       | 说明                 |&lt;br&gt;|—————————|———————|&lt;br&gt;| Serial Dispatch Queue     | 等待现在执行中处理结束  |&lt;br&gt;| Concurrent Dispatch Queue | 不等待现在执行中处理结束 |&lt;/p&gt;
&lt;p&gt;什么意思呢？举个例子，我们去银行办理业务的时候，通常都会拿号，针对不同的业务，我们可以拿不同形式的号，譬如VIP业务和普通的业务。由于VIP业务不是人人都需要，通常只保留一个通道，相反，普通业务办理的人数会很多，那就需要很多通道。对于办理VIP业务的人来讲，只有等号数在自己前面的人办理完毕后，自己才能去办理自己的业务，这就是我们所说的Serial Dispatch Queue。而办理普通业务的人呢？只要前面通道空闲了，后面的人就可以有序的去办理自己的业务，Concurrent Dispatch Queue也就对应这种场景了。&lt;/p&gt;
&lt;h5 id=&quot;dispatch-queue-create创建&quot;&gt;&lt;a href=&quot;#dispatch-queue-create创建&quot; class=&quot;headerlink&quot; title=&quot;dispatch_queue_create创建&quot;&gt;&lt;/a&gt;dispatch_queue_create创建&lt;/h5&gt;&lt;p&gt;上面讲的两种队列创建，可以利用dispatch_queue_create来创建：&lt;br&gt;&lt;figure class=&quot;highlight swift&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// Serial Dispatch Queue&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; queue = dispatch_queue_create(&lt;span class=&quot;string&quot;&gt;&quot;com.ysenin.multiplethread&quot;&lt;/span&gt;, &lt;span class=&quot;type&quot;&gt;DISPATCH_QUEUE_SERIAL&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; queue = dispatch_queue_create(&lt;span class=&quot;string&quot;&gt;&quot;com.ysenin.multiplethread&quot;&lt;/span&gt;, &lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// Concurrent Dispatch Queue&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; queue = dispatch_queue_create(&lt;span class=&quot;string&quot;&gt;&quot;com.ysenin.multiplethread&quot;&lt;/span&gt;, &lt;span class=&quot;type&quot;&gt;DISPATCH_QUEUE_CONCURRENT&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;通过上面的代码我们可以看到，dispatch_queue_create含有两个参数：第一个是队列名称，第二个是类型。对于队列名，苹果官方的描述如下：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;A string label to attach to the queue to uniquely identify it in debugging tools such as Instruments…&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;意思是说，这个名字仅仅是在你调试的时候知道是哪个线程而已。那么不同对象产生的相同名字的队列，它就是两个区分开的队列。针对这个问题，也是让我思考了很久，然后在&lt;a href=&quot;http://stackoverflow.com/questions/19421283/do-2-objects-creating-serial-queues-with-the-same-name-share-the-same-queue&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;stackoverflow&lt;/a&gt;中找到答案了。&lt;/p&gt;
&lt;p&gt;对于Serial Dispatch Queue，我们看到有两种dispatch_queue_create创建方法，第二个参数可以默认为nil，也可以添加DISPATCH_QUEUE_SERIAL来标识。对于Serial Dispatch Queue，我们可以生成多个，多个队列将并行执行。什么意思呢，还是拿银行的VIP业务例子来说明吧。在同一个地区，有同一个银行的不同的分行，每个分行都有VIP通道，这些通道互不影响，并行处理自己的业务。问题在于，如果一个地区如果有成千上万个分行，但事实上只有10个分行有人办理VIP业务，其他银行也就相当于浪费了。这就是前面提到的大量的生成线程，消耗大量的内存，引起大量的上下文切换，造成不必要浪费。因为，在实际编程中，我们需要避免这类似的情况发生。&lt;/p&gt;
&lt;p&gt;那么使用Serial Dispatch Queue也不是没有好处，因为在多线程更新数据的情况下，我们可能遇到多个线程更新到同一个数据。那么Serial Dispatch Queue就很好的避免了这个情况。也不是说完全避免，只是在绝大部分情况下，出现数据竞争的机率变小了。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;说明&lt;/strong&gt;&lt;br&gt;在iOS 6.0和OS X10.8的版本，已经引入ARC，因此不需要自己去管理内存。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Serial Dispatch Queue样例代码:&lt;br&gt;&lt;figure class=&quot;highlight swift&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; queue = dispatch_queue_create(&lt;span class=&quot;string&quot;&gt;&quot;com.ysenin.multiplethread&quot;&lt;/span&gt;, &lt;span class=&quot;type&quot;&gt;DISPATCH_QUEUE_SERIAL&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; i &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;..&amp;lt;&lt;span class=&quot;number&quot;&gt;1000&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    dispatch_async(queue, &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;block: &lt;span class=&quot;subst&quot;&gt;\(i)&lt;/span&gt;&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// Sample Output&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;block: &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;block: &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;block: &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;block: &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;block: &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;block: &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;block: &lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;block: &lt;span class=&quot;number&quot;&gt;7&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;block: &lt;span class=&quot;number&quot;&gt;8&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;...&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;Concurrent Dispatch Queue样例代码:&lt;br&gt;&lt;figure class=&quot;highlight swift&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; queue = dispatch_queue_create(&lt;span class=&quot;string&quot;&gt;&quot;com.ysenin.multiplethread&quot;&lt;/span&gt;, &lt;span class=&quot;type&quot;&gt;DISPATCH_QUEUE_CONCURRENT&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; i &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;..&amp;lt;&lt;span class=&quot;number&quot;&gt;1000&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    dispatch_async(queue, &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;block: &lt;span class=&quot;subst&quot;&gt;\(i)&lt;/span&gt;&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// Sample Output&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;block: &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;block: &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;block: &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;block: &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;block: &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;block: &lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;block: &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;block: &lt;span class=&quot;number&quot;&gt;7&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;block: &lt;span class=&quot;number&quot;&gt;8&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;...&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;针对于具有相同名称的Serial Dispatch Queue生成的多个queue源码示例如下：&lt;br&gt;&lt;figure class=&quot;highlight swift&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; queue = dispatch_queue_create(&lt;span class=&quot;string&quot;&gt;&quot;com.ysenin.multiplethread&quot;&lt;/span&gt;, &lt;span class=&quot;type&quot;&gt;DISPATCH_QUEUE_SERIAL&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; i &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;..&amp;lt;&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    dispatch_async(queue, &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;block: &lt;span class=&quot;subst&quot;&gt;\(i)&lt;/span&gt;&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;queue = dispatch_queue_create(&lt;span class=&quot;string&quot;&gt;&quot;com.ysenin.multiplethread&quot;&lt;/span&gt;, &lt;span class=&quot;type&quot;&gt;DISPATCH_QUEUE_SERIAL&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; i &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;..&amp;lt;&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    dispatch_async(queue, &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;block123: &lt;span class=&quot;subst&quot;&gt;\(i)&lt;/span&gt;&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// Sample Output&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;block: &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;block123: &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;block: &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;block123: &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;block: &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;block123: &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;block: &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;block123: &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;block: &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;block123: &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;block: &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;block123: &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;block: &lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;block123: &lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;block: &lt;span class=&quot;number&quot;&gt;7&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;block123: &lt;span class=&quot;number&quot;&gt;7&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;block: &lt;span class=&quot;number&quot;&gt;8&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;block123: &lt;span class=&quot;number&quot;&gt;8&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;block: &lt;span class=&quot;number&quot;&gt;9&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;block123: &lt;span class=&quot;number&quot;&gt;9&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h5 id=&quot;Global-Dispatch-Queue创建&quot;&gt;&lt;a href=&quot;#Global-Dispatch-Queue创建&quot; class=&quot;headerlink&quot; title=&quot;Global Dispatch Queue创建&quot;&gt;&lt;/a&gt;Global Dispatch Queue创建&lt;/h5&gt;&lt;p&gt;这个是获取系统标准提供的Dispatch Queue。也即是说，我们可以不需要像上一节提供的那样自己创建Dispatch Queue,系统自己会给我们提供几个Dispatch Queue使用，分别是：Main Dispatch Queue和Global Dispatch Queue。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Main Dispatch Queue顾名思义就是主线程中执行的Dispatch Queue，因为主线程只有1个，所以Main Dispatch Queue也就是Serial Dispatch Queue。另外一个Global Dispatch Queue是所有应用程序都能使用的Concurrent Dispatch Queue。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Global Dispatch Queue有4个优先级，分别是High Priority(最高优先级)、 Default Priority(默认优先级)、 Low Priority(低优先级)、 Background Priority(后台优先级)。通过XNU内核管理用于Global Dispatch Queue的线程，将各自使用的Global Dispatch Queue的执行优先级作为线程执行的优先级。在Global Dispatch Queue追加处理时，应该选择与处理内容对应的执行优先级的Global Dispatch Queue。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注意：XUN内核用语Global Dispatch Queue的线程并不能保证实时性，因此优先级之时大致的判断。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;关于Global Dispatch Queue获取和使用的源代码如下：&lt;br&gt;&lt;figure class=&quot;highlight swift&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; mainQueue = dispatch_get_main_queue() &lt;span class=&quot;comment&quot;&gt;// Main Dispatch Queue的获取方法&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/**&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  * Global Dispatch Queue获取&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  * DISPATCH_QUEUE_PRIORITY_HIGH       -- 最高优先级&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  * DISPATCH_QUEUE_PRIORITY_DEFAULT    -- 默认优先级&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  * DISPATCH_QUEUE_PRIORITY_LOW        -- 低优先级&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  * DISPATCH_QUEUE_PRIORITY_BACKGROUND -- 后台优先级&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 其他按照上面给出来的名称，改变参数就可以了&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; queue = dispatch_get_global_queue(&lt;span class=&quot;type&quot;&gt;DISPATCH_QUEUE_PRIORITY_HIGH&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;dispatch_async(queue, ^&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 可执行的处理&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    dispatch_async(mainQueue, ^&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 主线程中的处理&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h5 id=&quot;dispatch-set-target-queue&quot;&gt;&lt;a href=&quot;#dispatch-set-target-queue&quot; class=&quot;headerlink&quot; title=&quot;dispatch_set_target_queue&quot;&gt;&lt;/a&gt;dispatch_set_target_queue&lt;/h5&gt;&lt;p&gt;关于这个函数，有两种功能：1.变更Dispatch Queue的执行优先级；2.作为Dispatch Queue的执行阶层。&lt;/p&gt;
&lt;p&gt;第一个功能意思是什么呢？我们看下dispatch_set_target_queue(sourceQueue, goalQueue)。第一个参数为源Dispatch Queue，第二个参数为目标Dispatch Queue。那么结果就是将源Dispatch Queue的优先级设置为目标Dispatch Queue的优先级。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注: dispatch_queue_create创建的Dispatch Queue，不管是Serial Dispatch Queue还是Concurrent Dispatch Queue，默认优先级都是Global Dispatch Queue中的DISPATCH_QUEUE_PRIORITY_DEFAULT相同的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;至于第二个功能嘛，很简单，可以理解为，合并几个通过dispatch_queue_create创建的Dispatch Queue为1个Serial Dispatch Queue。当然啦，也可以作为Concurrent Dispatch Queue。但是那不就是合并之前Dispatch Queue嘛。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注：只能合并dispatch_queue_create创建的Dispatch Queue，不能合并通过Global Dispatch Queue创建，至于为什么嘛，啥时候找找原理，测试是不可以的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;第二个功能的示例代码如下：&lt;br&gt;&lt;figure class=&quot;highlight swift&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;testTargetQueue&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; targetQueue = dispatch_queue_create(&lt;span class=&quot;string&quot;&gt;&quot;target&quot;&lt;/span&gt;, &lt;span class=&quot;type&quot;&gt;DISPATCH_QUEUE_SERIAL&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; queue1 = dispatch_queue_create(&lt;span class=&quot;string&quot;&gt;&quot;queue1&quot;&lt;/span&gt;, &lt;span class=&quot;type&quot;&gt;DISPATCH_QUEUE_SERIAL&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; queue2 = dispatch_queue_create(&lt;span class=&quot;string&quot;&gt;&quot;queue2&quot;&lt;/span&gt;, &lt;span class=&quot;type&quot;&gt;DISPATCH_QUEUE_CONCURRENT&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; queue3 = dispatch_get_global_queue(&lt;span class=&quot;type&quot;&gt;DISPATCH_QUEUE_PRIORITY_DEFAULT&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    dispatch_set_target_queue(queue1, targetQueue)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    dispatch_set_target_queue(queue2, targetQueue)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    dispatch_set_target_queue(queue3, targetQueue)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    dispatch_async(queue1) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;start queue1&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;type&quot;&gt;NSThread&lt;/span&gt;.sleepForTimeInterval(&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;end queue1&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    dispatch_async(queue2) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;start queue2&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;type&quot;&gt;NSThread&lt;/span&gt;.sleepForTimeInterval(&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;end queue2&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    dispatch_async(queue3) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;start queue3&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;type&quot;&gt;NSThread&lt;/span&gt;.sleepForTimeInterval(&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;end queue3&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// Sample Output:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;start queue3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;start queue1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;end queue3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;end queue1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;start queue2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;end queue2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;通过上面的样例输出，可以看到Global Dispatch Queue是不能通过dispatch_set_target_queue改变执行阶级的。&lt;/p&gt;
&lt;h5 id=&quot;dispatch-after&quot;&gt;&lt;a href=&quot;#dispatch-after&quot; class=&quot;headerlink&quot; title=&quot;dispatch_after&quot;&gt;&lt;/a&gt;dispatch_after&lt;/h5&gt;&lt;p&gt;简单说一下，就是多长时间之后，执行需要的操作。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;dispatch_after(time, queue, block)&lt;br&gt;time: dispatch_time(DISPATCH_TIME_NOW, Int64(3 * NSEC_PER_SEC))&lt;br&gt;          startTime: 起始时间&lt;br&gt;          endTime: 相对的结束时间&lt;br&gt;queue: 在哪个线程队列中执行&lt;br&gt;block: 执行的操作&lt;/p&gt;
&lt;p&gt;注：dispatch_after的time，并不是绝对的时间，实际时间决定于该线程所在的runloop的执行时间，例如，runloop每0.01秒执行一次，那就是最快time，最慢响应时间为time + 0.01。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5 id=&quot;Dispatch-Group&quot;&gt;&lt;a href=&quot;#Dispatch-Group&quot; class=&quot;headerlink&quot; title=&quot;Dispatch Group&quot;&gt;&lt;/a&gt;Dispatch Group&lt;/h5&gt;&lt;p&gt;在追加到Dipatch Queue中的多个处理全部结束后，想执行结束操作。如果只使用Serial Dispatch Queue，这需要前者处理完毕之后，后面的才能有序的处理，在时间效率上会比较低下。在这种情况下，使用Dispatch Group，就可以轻松搞定。&lt;br&gt;示例代码如下：&lt;br&gt;&lt;figure class=&quot;highlight swift&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; group = dispatch_group_create()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; queue = dispatch_get_global_queue(&lt;span class=&quot;type&quot;&gt;DISPATCH_QUEUE_PRIORITY_DEFAULT&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;dispatch_group_async(group, queue) &amp;#123; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;block 1&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;dispatch_group_async(group, queue) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;block 2&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;dispatch_group_async(group, queue) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;block 3&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;dispatch_group_notify(group, dispatch_get_main_queue()) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;done&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// Sample Output&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;block &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;block &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;block &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;done&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;当然，在我们执行的group的过程中，我们是可以等待追加的所有处理完毕，之后再进行下一步处理，也可以在我们规定的时间内，进行下一步操作。那么，这就需要用到dispatch_group_wait(group, DISPATCH_TIME_FOREVER)。第一个参数：上面定义的group；第二个参数：定义的执行时间，DISPATCH_TIME_FOREVER即等待所有执行结束，也可以使用dispatch_time定义的等待时间。具体代码如下：&lt;br&gt;&lt;figure class=&quot;highlight swift&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; time = dispatch_time(&lt;span class=&quot;type&quot;&gt;DISPATCH_TIME_NOW&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; result = dispatch_group_wait(group, time)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; result == &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;Done&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;Not Finish.&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// Sample Output:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;type&quot;&gt;Not&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;Finish&lt;/span&gt;.&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h5 id=&quot;dispatch-barrier-async&quot;&gt;&lt;a href=&quot;#dispatch-barrier-async&quot; class=&quot;headerlink&quot; title=&quot;dispatch_barrier_async&quot;&gt;&lt;/a&gt;dispatch_barrier_async&lt;/h5&gt;&lt;p&gt;这是个什么函数呢？还是给个场景吧，数据库读写的时候，发现在我们更新到的时候，需要写入数据。那么，在更新前是不需要什么处理的，但更新后的数据想要读出新数据，这该怎么办呢？&lt;/p&gt;
&lt;p&gt;上面的问题，我们可以通过Serial Dispatch Queue处理，Serial Dispatch Queue的特性又是单通道，只能串行执行，效率不高。在这种情况下，GCD给我们提供了更加聪明的方法dispatch_barrier_async。配合Concurrent Dispatch Queue使用dispatch_barrier_async处理，会将更新的数据并行执行，处理完成后做dispatch_barrier_async的追加处理，之后再做余下的并行执行。&lt;/p&gt;
&lt;p&gt;也就是说，dispatch_barrier_async类似于坐过山车，前面的人怎么排队都好，只有人齐才会发车。只有过山车停，人才可以下来，然后做各自喜欢的事情。那么dispatch_barrier_async就很好的把控了两者之间的关口，达到数据统一。&lt;/p&gt;
&lt;p&gt;dispatch_barrier_async(queue, block)，第一个参数为处理的队列，第二个为执行的处理。示例代码如下：&lt;br&gt;&lt;figure class=&quot;highlight swift&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;47&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;48&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;49&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;50&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;51&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;52&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;53&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;54&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;55&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;56&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;57&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;58&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;59&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; queue = dispatch_queue_create(&lt;span class=&quot;string&quot;&gt;&quot;text&quot;&lt;/span&gt;, &lt;span class=&quot;type&quot;&gt;DISPATCH_QUEUE_CONCURRENT&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;dispatch_async(queue) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;handler start 1&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;type&quot;&gt;NSThread&lt;/span&gt;.sleepForTimeInterval(&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;handler end 1&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;dispatch_async(queue) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;handler start 2&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;type&quot;&gt;NSThread&lt;/span&gt;.sleepForTimeInterval(&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;handler end 2&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;dispatch_async(queue) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;handler start 3&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;type&quot;&gt;NSThread&lt;/span&gt;.sleepForTimeInterval(&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;handler end 3&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;dispatch_barrier_async(queue) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;barrier handler start&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;type&quot;&gt;NSThread&lt;/span&gt;.sleepForTimeInterval(&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;barrier handler end&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;dispatch_async(queue) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;handler start 4&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;type&quot;&gt;NSThread&lt;/span&gt;.sleepForTimeInterval(&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;handler end 4&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;dispatch_async(queue) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;handler start 5&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;type&quot;&gt;NSThread&lt;/span&gt;.sleepForTimeInterval(&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;handler end 5&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;dispatch_async(queue) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;handler start 6&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;type&quot;&gt;NSThread&lt;/span&gt;.sleepForTimeInterval(&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;handler end 6&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// Sample Output&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;handler start &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;handler start &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;handler start &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;handler end &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;handler end &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;handler end &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;barrier handler start&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;barrier handler end&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;handler start &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;handler start &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;handler start &lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;handler end &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;handler end &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;handler end &lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;值得注意一点的就是：我们生成的Dispatch Queue必须是通过dispatch_queue_create生成的Concurrent Dispatch Queu，否则无效，即使Global Dispatch Queue在一定意义上也是Concurrent Dispatch Queu。&lt;/p&gt;
&lt;h5 id=&quot;dispatch-apply&quot;&gt;&lt;a href=&quot;#dispatch-apply&quot; class=&quot;headerlink&quot; title=&quot;dispatch_apply&quot;&gt;&lt;/a&gt;dispatch_apply&lt;/h5&gt;&lt;p&gt;dispatch_apple函数时dispatch_sync函数和Dispatch Group的关联API，高函数制定的次数将指定的block追加到Dispatch Queue中，并等待结束。开示例代码吧，这个容易懂：&lt;br&gt;&lt;figure class=&quot;highlight swift&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; queue = dispatch_get_global_queue(&lt;span class=&quot;type&quot;&gt;DISPATCH_QUEUE_PRIORITY_DEFAULT&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; array: [&lt;span class=&quot;type&quot;&gt;Int&lt;/span&gt;] = [&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;7&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;8&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;9&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;dispatch_apply(array.&lt;span class=&quot;built_in&quot;&gt;count&lt;/span&gt;, queue) &amp;#123; (index: &lt;span class=&quot;type&quot;&gt;Int&lt;/span&gt;) &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;print&lt;/span&gt;(array[index])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;done&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// Sample Output&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;7&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;8&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;9&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;done&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;dispatch_apply(count, queue, block(index: Int))，第一个参数为执行几次，第二个参数为执行的队列，第三个参数为执行的第index个block。通过示例代码我们会发现，在dispatch_apply内部的block是异步执行的，但只有执行完count次之后，才会结束。也就是说，dispatch_apply是同步的，但在内部的count次block执行，确实异步的。&lt;br&gt;因此，在实际处理过程中，将dispatch_apply写在异步执行代码块中。&lt;/p&gt;
&lt;h5 id=&quot;dispatch-suspend-dispatch-resume&quot;&gt;&lt;a href=&quot;#dispatch-suspend-dispatch-resume&quot; class=&quot;headerlink&quot; title=&quot;dispatch_suspend/dispatch_resume&quot;&gt;&lt;/a&gt;dispatch_suspend/dispatch_resume&lt;/h5&gt;&lt;p&gt;dispatch_suspend(queue): 将queue挂起，即放到阻塞线程中，等待激活。&lt;br&gt;dispatch_resume(queue): 恢复queue，从阻塞状态变为就绪状态，等到执行。&lt;/p&gt;
&lt;h5 id=&quot;dispatch-once&quot;&gt;&lt;a href=&quot;#dispatch-once&quot; class=&quot;headerlink&quot; title=&quot;dispatch_once&quot;&gt;&lt;/a&gt;dispatch_once&lt;/h5&gt;&lt;p&gt;dispatch_once保证在应用程序中只执行一次处理，主要解决在多线程环境下，保证安全。常用于单例模式，生成单例对象时使用。&lt;br&gt;示例代码：&lt;br&gt;&lt;figure class=&quot;highlight swift&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;shareInstance&lt;/span&gt;: &lt;span class=&quot;title&quot;&gt;SYObjectClass&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Static&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; onceToken: dispatch_once_t = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; instance: &lt;span class=&quot;type&quot;&gt;SYObjectClass&lt;/span&gt;?&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    dispatch_once(&amp;amp;&lt;span class=&quot;type&quot;&gt;Static&lt;/span&gt;.onceToken) &amp;#123; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;type&quot;&gt;Static&lt;/span&gt;.instance = &lt;span class=&quot;type&quot;&gt;SYObjectClass&lt;/span&gt;()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;Static&lt;/span&gt;.instance!&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&quot;后记&quot;&gt;&lt;a href=&quot;#后记&quot; class=&quot;headerlink&quot; title=&quot;后记&quot;&gt;&lt;/a&gt;后记&lt;/h3&gt;&lt;p&gt;花了几天时间，把GCD看了下，以前没怎么仔细花功夫看过，因此这次所花的时间还是值得的，把之前关于GCD比较纳闷的问题解决了一下。GCD是纯C语言的API；处理同步数据的时候非常高效，不需要添加同步锁；使用GCD的dispatch_once也可以保证在多线程中之生成一个对象等。至于和几种方式的区别，会在接下来几篇关于多线程处理方法写完之后做一个总结。不管怎样，只有在项目中在适当的地方，添加合适的多线程处理方式，才能让项目变得更加好。&lt;/p&gt;
&lt;h3 id=&quot;参考文献&quot;&gt;&lt;a href=&quot;#参考文献&quot; class=&quot;headerlink&quot; title=&quot;参考文献&quot;&gt;&lt;/a&gt;参考文献&lt;/h3&gt;&lt;p&gt;1.[Objective-C高级编程 iOS与OS X多线程和内存指南]&lt;br&gt;2.[Effective Objective-C 2.0编写高质量iOS和OS X代码的52个有效方法]&lt;br&gt;3.&lt;a href=&quot;http://www.infoq.com/cn/articles/os-x-ios-multithread-technology&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;OS X 和 iOS 中的多线程技术&lt;/a&gt;&lt;br&gt;4.&lt;a href=&quot;https://www.zybuluo.com/MicroCai/note/64272&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Effective Objective-C Notes：GCD 实现同步锁&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;网上关于多线程的文章已经烂大街了，问题是为啥我还要继续写呢？没有为啥，单纯想写。看到有些文章空泛的描述出使用的什么方法来生成多线程，然后就扔一堆代码，这种做法真是令人作呕，至少我是这么觉得的。好吧，调侃的差不多了，也来写写自己对于多线程的理解，那么这一片会首先介绍GCD。文章主要参考[Objective-C高级编程、iOS与OS X多线程和内存指南]，一本很不错的书。算了还是不要说参考了，摘抄。&lt;/p&gt;
    
    </summary>
    
      <category term="多线程" scheme="http://yoursite.com/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
      <category term="Swift" scheme="http://yoursite.com/tags/Swift/"/>
    
      <category term="多线程" scheme="http://yoursite.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="GCD" scheme="http://yoursite.com/tags/GCD/"/>
    
  </entry>
  
  <entry>
    <title>iOS在分类(Category)中添加并使用属性</title>
    <link href="http://yoursite.com/2016/06/22/iOS%E5%88%A9%E7%94%A8Runtime%E6%9C%BA%E5%88%B6%E6%B7%BB%E5%8A%A0%E9%A2%9D%E5%A4%96%E7%9A%84%E5%B1%9E%E6%80%A7/"/>
    <id>http://yoursite.com/2016/06/22/iOS利用Runtime机制添加额外的属性/</id>
    <published>2016-06-22T13:40:51.000Z</published>
    <updated>2017-10-20T03:11:08.212Z</updated>
    
    <content type="html">&lt;p&gt;在很多时候，我们想给某些类增加一些属性，用于传值或者用做与其他用途。问题在于，调用系统给定的类，使得我们无法去做更改，必须通过代理、通知之类的方式传递。这类似的做法，让我们变得非常被动，写一堆代码， 只是为了传递一个小参数。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;对于此类问题的解决方案呢，是利用Runtime机制，在分类里给某个类增加额外的属性。按理说，分类是允许添加属性的，但不会自动生成getter和setter方法的。可为啥我们还是可以在分类增加属性，并能生成getter和setter方法呢？那么这就说到我们的黑魔法–Runtime的关联引用。&lt;/p&gt;
&lt;p&gt;给个场景吧，曾今在项目中遇到过的问题。在UITableViewCell的contentView中添加一个自定义button，button用于头像显示，点击头像显示大图。解决方案有很多种，例如设置button的tag为cell indexPath.row、判断点击区域等。现在我想通过button的属性来确定点击button的值，该怎么做呢？&lt;/p&gt;
&lt;p&gt;前面我们说到，可以在分类(Category)添加属性，并通过关联引用来设置属性getter和setter方法。现在我们给button增加一个iamgeName属性，用于显示图片的名称。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;@property (nonatomic, copy) NSString *imageName;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;1.项目介绍，主要是自定义cell中，添加button，点击button打印button的imageName.&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;figcaption&gt;&lt;span&gt;[lang:.m] [title] [url] [link text]&lt;/span&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;47&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;48&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;49&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;50&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;51&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;52&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;53&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;54&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;55&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;56&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;57&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;58&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;59&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;60&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;61&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;62&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;ViewController.m&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    SYTableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:@&amp;quot;cell&amp;quot;]; // 自定义cell&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if (cell == nil) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        cell = [[SYTableViewCell alloc] initWithStyle:UITableViewCellStyleDefault reuseIdentifier:@&amp;quot;cell&amp;quot;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [cell setHeaderImage:@&amp;quot;header.jpg&amp;quot;]; // button的图片&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return cell;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//  SYTableViewCell.h&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#import &amp;lt;UIKit/UIKit.h&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#import &amp;quot;UIButton+SYAssociteObject.h&amp;quot; // 黑魔法文件&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@interface SYTableViewCell : UITableViewCell&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@property (nonatomic, strong) UIButton *button;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (void)setHeaderImage:(NSString *)imageName;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@end&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//  SYTableViewCell.m&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#import &amp;quot;SYTableViewCell.h&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@implementation SYTableViewCell&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (id)initWithStyle:(UITableViewCellStyle)style reuseIdentifier:(NSString *)reuseIdentifier &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    self = [super initWithStyle:style reuseIdentifier:reuseIdentifier];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if (self) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        _button = [UIButton buttonWithType:UIButtonTypeCustom];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        _button.frame = CGRectMake(15, 5, 40, 40);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        _button.layer.cornerRadius = 5;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        _button.layer.masksToBounds = YES;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        _button.backgroundColor = [UIColor redColor];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        [_button addTarget:self action:@selector(buttonAction:) forControlEvents:UIControlEventTouchUpInside];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        _button.imageName = @&amp;quot;gaga&amp;quot;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        [self addSubview:_button];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return self;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (void)setHeaderImage:(NSString *)imageName &amp;#123; // 设置button图片&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    _button.imageName = imageName;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [_button setImage:[UIImage imageNamed:imageName] forState:UIControlStateNormal];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (void)buttonAction:(UIButton *)sender &amp;#123; // 点击button响应事件&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    NSLog(@&amp;quot;%@&amp;quot;, sender.imageName);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@end&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;2.黑魔法文件，方法1，2，3，4只是相同的方法实现，不同的参数而已。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;//  UIButton+SYAssociteObject.h&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#import &amp;lt;UIKit/UIKit.h&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@interface UIButton (SYAssociteObject)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@property (nonatomic, copy) NSString *imageName;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@end&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//  UIButton+SYAssociteObject.m&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#import &amp;quot;UIButton+SYAssociteObject.h&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#import &amp;lt;objc/runtime.h&amp;gt; // 很重要&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@implementation UIButton (SYAssociteObject)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 方法1，2，3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;static void *strKey = &amp;amp;strKey;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;static NSString *charKey = @&amp;quot;char&amp;quot;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;static char str;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (void)setImageName:(NSString *)imageName &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    objc_setAssociatedObject(self, &amp;amp;strKey, imageName, OBJC_ASSOCIATION_COPY_NONATOMIC);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (NSString *)imageName &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return objc_getAssociatedObject(self, &amp;amp;strKey);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 方法4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//- (void)setImageName:(NSString *)name &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//    objc_setAssociatedObject(self, @selector(imageName), name, OBJC_ASSOCIATION_COPY_NONATOMIC);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//- (NSString *)imageName &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//    return objc_getAssociatedObject(self, @selector(imageName));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@end&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;getter和setter方法都试利用关联引用，setter中包涵四个属性(源对象，关联key，关联对象，关联策略)。关联对象即我们的目标对象，关联策略即我们平时使用的修饰符，如下所示：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt; typedef OBJC_ENUM(uintptr_t, objc_AssociationPolicy) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    OBJC_ASSOCIATION_ASSIGN = 0,           //  ==&amp;gt; 指定assign引用关联的对象&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    OBJC_ASSOCIATION_RETAIN_NONATOMIC = 1, //  ==&amp;gt; 指定retain非原子属性的关联的对象&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    OBJC_ASSOCIATION_COPY_NONATOMIC = 3,   //  ==&amp;gt; 指定copy非原子属性的关联的对象&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    OBJC_ASSOCIATION_RETAIN = 01401,       //  ==&amp;gt; 指定retain原子属性的关联的对象&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    OBJC_ASSOCIATION_COPY = 01403          //  ==&amp;gt; 指定copy原子属性的关联的对象&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;以上就是给我们不能添加属性的类，增加自定义属性。正如上面提到的场景，当我们点击button的使用，就可以传递我们需要的参数，而不是使用通知等方法来实现此类结果。虽然文件项目增加了，但是用着确实非常舒服。当然，如果你还有其他方法，也欢迎一起探讨。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;在很多时候，我们想给某些类增加一些属性，用于传值或者用做与其他用途。问题在于，调用系统给定的类，使得我们无法去做更改，必须通过代理、通知之类的方式传递。这类似的做法，让我们变得非常被动，写一堆代码， 只是为了传递一个小参数。&lt;/p&gt;
    
    </summary>
    
      <category term="Runtime" scheme="http://yoursite.com/categories/Runtime/"/>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
      <category term="Runtime" scheme="http://yoursite.com/tags/Runtime/"/>
    
      <category term="Objective-C" scheme="http://yoursite.com/tags/Objective-C/"/>
    
  </entry>
  
  <entry>
    <title>iOS 10权限使用</title>
    <link href="http://yoursite.com/2016/06/21/iOS-10%E6%9D%83%E9%99%90%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2016/06/21/iOS-10权限使用/</id>
    <published>2016-06-21T03:49:28.000Z</published>
    <updated>2017-10-20T03:03:45.613Z</updated>
    
    <content type="html">&lt;p&gt;前几天升级iOS 10，想体验一下，bug实在是太多了，改天写篇文章说一下遇到的相关问题好了。现在iOS 10是开发者的预览版，还没有公开测试版，也就是说通过开发者可以获得一个profile链接，然后下载就可以了。至于Xcode8.0嘛，那就直接在&lt;a href=&quot;https://developer.apple.com/download/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;苹果开发者网站&lt;/a&gt;下载就没问题了，网速慢的话，度娘也可以。那么先说今天遇到的问题吧，在今天准备真机测试的时候发现崩溃了，就这么崩溃了。泪崩，以前都没有遇到过。是什么问题呢？看一下Console的log吧。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;blockquote&gt;
&lt;p&gt;This app has crashed because it attempted to access privacy-sensitive data without a usage description.  The app’s Info.plist must contain an NSCameraUsageDescription key with a string value explaining to the user how the app uses this data.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;大概意思就是：应用崩溃了，主要原因是访问了没有描述的敏感数据，如果要使用就必须在应用的Info.plist文件中必须添加一个NSCameraUsageDescription的字符串key，来解释应用如何使用这些数据。&lt;/p&gt;
&lt;p&gt;当然，如果你要使用其他权限，使用相应的key就可以了，因为权限造成的崩溃的时候，将该key添加到Info.plist文件中即可。value就可以随便定义，中文也可以。常见的key如下：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;相机： NSCameraUsageDescriptio: ncameraDesciption&lt;br&gt;通信录： NSContactsUsageDescription: contactsDesciption&lt;br&gt;麦克风： NSMicrophoneUsageDescription: microphoneDesciption&lt;br&gt;相机： NSPhotoLibraryUsageDescription: photoLibraryDesciption&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Info.plist截图如下：&lt;br&gt;&lt;img src=&quot;/images/plist.jpg&quot; alt=&quot;plist截图&quot;&gt;&lt;/p&gt;
&lt;p&gt;之后编译运行就可以正常使用，不会出现崩溃显现想了。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;前几天升级iOS 10，想体验一下，bug实在是太多了，改天写篇文章说一下遇到的相关问题好了。现在iOS 10是开发者的预览版，还没有公开测试版，也就是说通过开发者可以获得一个profile链接，然后下载就可以了。至于Xcode8.0嘛，那就直接在&lt;a href=&quot;https://developer.apple.com/download/&quot;&gt;苹果开发者网站&lt;/a&gt;下载就没问题了，网速慢的话，度娘也可以。那么先说今天遇到的问题吧，在今天准备真机测试的时候发现崩溃了，就这么崩溃了。泪崩，以前都没有遇到过。是什么问题呢？看一下Console的log吧。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS 10" scheme="http://yoursite.com/categories/iOS-10/"/>
    
    
      <category term="iOS 10" scheme="http://yoursite.com/tags/iOS-10/"/>
    
  </entry>
  
  <entry>
    <title>MBProgressHUD源码解读</title>
    <link href="http://yoursite.com/2016/05/24/MBProgressHUD%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"/>
    <id>http://yoursite.com/2016/05/24/MBProgressHUD源码解读/</id>
    <published>2016-05-24T15:10:24.000Z</published>
    <updated>2017-10-20T03:36:10.001Z</updated>
    
    <content type="html">&lt;p&gt; 源码参见：&lt;a href=&quot;https://github.com/jdg/MBProgressHUD&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/jdg/MBProgressHUD&lt;/a&gt;&lt;br&gt; 版本：0.9.2&lt;/p&gt;
&lt;h3 id=&quot;描述&quot;&gt;&lt;a href=&quot;#描述&quot; class=&quot;headerlink&quot; title=&quot;描述&quot;&gt;&lt;/a&gt;描述&lt;/h3&gt;&lt;p&gt;MBProgressHUD是一个HUD窗口的第三方库，用在执行一些后台任务时的，在程序显示一些进度和提示的窗口，其大部分时间都是用于一些网络交互时的进度提示等。相对于上个版本，这个版本添加了消失的动画，也修改了布局方式，采用约束来实现布局等。&lt;/p&gt;
&lt;p&gt;本文主要是从最新的源码讲解它的实现讲解。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;模式&quot;&gt;&lt;a href=&quot;#模式&quot; class=&quot;headerlink&quot; title=&quot;模式&quot;&gt;&lt;/a&gt;模式&lt;/h3&gt;&lt;p&gt;MBProgressHUD中定义了一个MBProgressHUDMode枚举类型，它主要是定义HUD显示的模式。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;typedef NS_ENUM(NSInteger, MBProgressHUDMode) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     /// 使用UIActivityIndicatorView显示进度，默认值&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     MBProgressHUDModeIndeterminate,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     /// 以前时饼状图，现在内外圈，两个圆环，内圈是一个圆环进度&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     MBProgressHUDModeDeterminate,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     /// 这个直观的来讲就是一个进度条&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     MBProgressHUDModeDeterminateHorizontalBar,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     /// 这是一个一个圆环进度条，和MBProgressHUDModeDeterminate相差不多。细节上的吧。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     MBProgressHUDModeAnnularDeterminate,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     /// 自定义控件view&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     MBProgressHUDModeCustomView,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     /// 只显示文字&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     MBProgressHUDModeText&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;通过设置mode，来显示不同的模式。当然，我们还可以设置title和detailTitle。这些都会在我们的设置中显示，在MBProgressHUD的Demo中可以看到这些不同mode的应用。&lt;/p&gt;
&lt;h3 id=&quot;动画&quot;&gt;&lt;a href=&quot;#动画&quot; class=&quot;headerlink&quot; title=&quot;动画&quot;&gt;&lt;/a&gt;动画&lt;/h3&gt;&lt;p&gt;在最新的version中（以前应该也有，没留意以前的代码），MBProgressHUD消失的时候使用了动画，这使得在使用HUD过程中提供了更好的交互体验。只不过动画，只在消失的时候提供了简单的几种类型。事实上显示的时候也是有动画的，由于构造方法没有添加相关值，因此只能使用默认动画显示。如果要修改显示时的动画，有两种方案，1.修改源代码；2.添加构造新的构造方法。相对于第一种，第二种方案的可塑性会更加好，也因此建议自己在源代码中添加自己的构造方法。动画类型如下所示：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;typedef NS_ENUM(NSInteger, MBProgressHUDAnimation) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    /// 不透明动画&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    MBProgressHUDAnimationFade,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    /// 从原比例到0.5倍比例&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    MBProgressHUDAnimationZoom,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    /// 从原比例到1.5倍比例&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    MBProgressHUDAnimationZoomOut,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   /// 从原比例到0.5倍比例&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   MBProgressHUDAnimationZoomIn&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&quot;视图&quot;&gt;&lt;a href=&quot;#视图&quot; class=&quot;headerlink&quot; title=&quot;视图&quot;&gt;&lt;/a&gt;视图&lt;/h3&gt;&lt;p&gt;MBProgressHUD分为几种类型，正如mode类型一样，期间的一些view和title是可以自由组合的。通过源码我们可以看到HUD中包含bezelView，titleLabel，detailLabel，button。然后在我们的视图中，通过模式的选择展现出来。&lt;/p&gt;
&lt;h3 id=&quot;属性&quot;&gt;&lt;a href=&quot;#属性&quot; class=&quot;headerlink&quot; title=&quot;属性&quot;&gt;&lt;/a&gt;属性&lt;/h3&gt;&lt;p&gt;MBProgressHUD提供了一些属性，给予我们更大的操作性，譬如宽限时间，最小显示时间，隐藏时是否从父视图移除等等。具体的如下所示：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;// 宽限时间，由于在使用HUD过程中，大部分都是用在网络请求过程中。如果网络请求过程很短，那么使用HUD在加载完毕就消失使得体验不是特别好。因此，可以使用graceTime赋予一个设定值，网络加载短于这个时间将不会显示HUD视图。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@property (assign, nonatomic) NSTimeInterval graceTime;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 最短显示时间，默认值为0. 在网络请求很短时，为了提供一个良好的交互体验，设置一个minShowTime，就算网络加载时间少于minShowTime，也至少会显示minShowTime的时间。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@property (assign, nonatomic) NSTimeInterval minShowTime;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 是否在隐藏时从父视图上移除，默认为NO&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@property (assign, nonatomic) BOOL removeFromSuperViewOnHide;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// HUD模式，参见模式类型&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@property (assign, nonatomic) MBProgressHUDMode mode;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 设置labels和indicators的主体颜色，同样还有tintColor。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@property (strong, nonatomic, nullable) UIColor *contentColor UI_APPEARANCE_SELECTOR;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 消失时的动画类型，参见动画。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@property (assign, nonatomic) MBProgressHUDAnimation animationType UI_APPEARANCE_SELECTOR;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// bezel视图相对于父视图的偏移量&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@property (assign, nonatomic) CGPoint offset UI_APPEARANCE_SELECTOR;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// HUD各元素与HUD边缘的距离，默认为20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@property (assign, nonatomic) CGFloat margin UI_APPEARANCE_SELECTOR;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// HUD bezel的最小大笑，默认为0&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@property (assign, nonatomic) CGSize minSize UI_APPEARANCE_SELECTOR;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 只读属性，HUD是否是正方形&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@property (assign, nonatomic, getter = isSquare) BOOL square UI_APPEARANCE_SELECTOR;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 这个不太清楚是干啥的&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@property (assign, nonatomic, getter=areDefaultMotionEffectsEnabled) BOOL defaultMotionEffectsEnabled UI_APPEARANCE_SELECTOR;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 进度， 一般网络下载数据时很有效果&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@property (assign, nonatomic) float progress;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&quot;构造函数&quot;&gt;&lt;a href=&quot;#构造函数&quot; class=&quot;headerlink&quot; title=&quot;构造函数&quot;&gt;&lt;/a&gt;构造函数&lt;/h3&gt;&lt;p&gt;在使用MBProgressHUD时，我们会发现三个构造方法可以使用。在新版本中，废弃了一些方法，替换了新方法。如下所示的三个方法，分别是生成HUD视图，隐藏HUD视图，从父视图查找HUD视图，具体描述如下所示：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt; /**&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; *&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * 创建一个你的HUD， 添加到并显示到提供的view上。对应的隐藏方法为hideHUDForView:animated:.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; *&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * 注意: 这个方法设置了当隐藏时从父视图移除的属性。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; *&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * @param view: 将在父视图view添加HUD&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * @param animated: 是否显示动画，如果设置YES，即表示即将显示HUD的时候会按照animationType显示，反之则不会显示动画。事实上animationType在初始化的时候，默认为.Fade，在显示的时候并不会根据设定的animationType来显示。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * @return 根据以上参数显示的HUD&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; *&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * @see 与之对应的隐藏参见hideHUDForView:animated:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * @see 动画显示参见animationType&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  + (instancetype)showHUDAddedTo:(UIView *)view animated:(BOOL)animated;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;/**&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; *&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * 寻找view中最顶端的HUD，对应的显示方法为showHUDAddedTo:animated:.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; *&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * 注意：这个方法会自动设置了removeFromSuperViewOnHide，即隐藏时，从父视图移除。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; *&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * @param view表示在传入的view查找是否存在HUD这个子视图&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * @param 当animated = YES时，表示在即将隐藏的时候会根据animationType的动画方式隐藏HUD视图，反之则不需要动画&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * 当HUD消失的时候执行animations动画&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * @return YES代表HUD找到了并且移除了，相反则返回NO&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; *&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * @see 对应的生成方法showHUDAddedTo:animated:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * @see 移除过程中的动画类型&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; + (BOOL)hideHUDForView:(UIView *)view animated:(BOOL)animated;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;/**&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * 寻找view上最顶层的HUD视图&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; *&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * @param view 即将要查询的父视图&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * @return 发现的最顶层的HUD视图&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; + (nullable MBProgressHUD *)HUDForView:(UIView *)view;`&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&quot;初始化&quot;&gt;&lt;a href=&quot;#初始化&quot; class=&quot;headerlink&quot; title=&quot;初始化&quot;&gt;&lt;/a&gt;初始化&lt;/h3&gt;&lt;p&gt;MBProgressHUD所有的初始化方法中，共同的初始化都只有一个函数&lt;strong&gt; - (void)commonInit &lt;/strong&gt;。在这个方法里，进行了各类属性的初始化值的设定，以及初始化视图、更新indicators和注册通知。如下所示:&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[self setupViews]; // 设置基本view&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[self updateIndicators]; // 更新indicators&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[self registerForNotifications]; // 注册通知&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;初始化视图和属性，这个没得说，就是我们需要显示视图的各类初始化。那么更新indicators这个方法呢，就是绑定我们我们设置的model方法，并根据model类型，设定HUD所需要显示的样式。注册通知，这个方法注册似的屏幕旋转时，需要改变的大小。&lt;/p&gt;
&lt;h3 id=&quot;关于新版本&quot;&gt;&lt;a href=&quot;#关于新版本&quot; class=&quot;headerlink&quot; title=&quot;关于新版本&quot;&gt;&lt;/a&gt;关于新版本&lt;/h3&gt;&lt;p&gt;最新版本0.9.2，相对于0.9.1做了很多调整。包括一些生成方法、属性、布局等，都做了调整。譬如，现在的布局方式采用了auto layout，以前是采用数学计算的方式来完成了，算是一个不小的调整。接着，有人说，当网络请求想消失时，之前的版本是无法做到的。那么在新的版本中，我们可以设置HUD中button的title值，target方法即可完成我们需要的功能了。新版本中废弃的方法，作者也是做出了相应提示。在&lt;strong&gt;MBProgressHUD (Deprecated)&lt;/strong&gt;中就可以查看那些方法是被废弃掉了的。&lt;/p&gt;
&lt;h3 id=&quot;后记&quot;&gt;&lt;a href=&quot;#后记&quot; class=&quot;headerlink&quot; title=&quot;后记&quot;&gt;&lt;/a&gt;后记&lt;/h3&gt;&lt;p&gt;老实说，写一篇源码剖析还真的不知道如何下手。因为也是第一次写博客吧，导致很多都不知道哪些属于重要的知识点。仅仅是自己觉得重要一些的，会拿出来讲。但反过头来再看，整篇文章是没有很多技术性的问题探讨。还是希望如果有人看到了，能指点迷津。在此谢过……&lt;/p&gt;
&lt;p&gt;参考：&lt;a href=&quot;http://southpeak.github.io/blog/2015/03/24/sourcecode-mbprogresshud/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;南峰子的技术博客&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt; 源码参见：&lt;a href=&quot;https://github.com/jdg/MBProgressHUD&quot;&gt;https://github.com/jdg/MBProgressHUD&lt;/a&gt;&lt;br&gt; 版本：0.9.2&lt;/p&gt;
&lt;h3 id=&quot;描述&quot;&gt;&lt;a href=&quot;#描述&quot; class=&quot;headerlink&quot; title=&quot;描述&quot;&gt;&lt;/a&gt;描述&lt;/h3&gt;&lt;p&gt;MBProgressHUD是一个HUD窗口的第三方库，用在执行一些后台任务时的，在程序显示一些进度和提示的窗口，其大部分时间都是用于一些网络交互时的进度提示等。相对于上个版本，这个版本添加了消失的动画，也修改了布局方式，采用约束来实现布局等。&lt;/p&gt;
&lt;p&gt;本文主要是从最新的源码讲解它的实现讲解。&lt;/p&gt;
    
    </summary>
    
      <category term="源码剖析" scheme="http://yoursite.com/categories/%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"/>
    
    
      <category term="源码剖析" scheme="http://yoursite.com/tags/%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"/>
    
  </entry>
  
</feed>
