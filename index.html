<!doctype html>



  


<html class="theme-next muse use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />





  <link rel="alternate" href="/atom.xml" title="ySenIn's Blog" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta name="description" content="一个孤独的人，一个不想孤独的人">
<meta property="og:type" content="website">
<meta property="og:title" content="ySenIn's Blog">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="ySenIn's Blog">
<meta property="og:description" content="一个孤独的人，一个不想孤独的人">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="ySenIn's Blog">
<meta name="twitter:description" content="一个孤独的人，一个不想孤独的人">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>

  <title> ySenIn's Blog </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">ySenIn's Blog</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">ySen</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-guestbook">
          <a href="/guestbook" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            留言
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/10/19/pinyin4objc源码阅读/" itemprop="url">
                  pinyin4objc源码阅读
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2017-10-19T14:43:32+08:00" content="2017-10-19">
              2017-10-19
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/源码剖析/" itemprop="url" rel="index">
                    <span itemprop="name">源码剖析</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2017/10/19/pinyin4objc源码阅读/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/10/19/pinyin4objc源码阅读/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>源码参见：<a href="https://github.com/kimziv/PinYin4Objc.git" target="_blank" rel="external">https://github.com/kimziv/PinYin4Objc.git</a><br>版本：1.1</p>
<h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>汉字转拼音，相信在很多app都会遇到，例如：通讯录、消息、搜索等。汉字转拼音有很多种方式可以是实现，本文所讲的是其中一种；当然，苹果也有自己的实现方式。苹果内部实现就真心不想吐槽了，超级慢，后续会找一些数据来说明。那么，接下来就看看PinYin4Objc是如何实现高效的转化。</p>
<h3 id="前注"><a href="#前注" class="headerlink" title="前注"></a>前注</h3><h4 id="常量、枚举"><a href="#常量、枚举" class="headerlink" title="常量、枚举"></a>常量、枚举</h4><p>在阅读源码之前，我们需要认识一下PinYin4Objc里面的常量以及枚举值：<br></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">#define HANYU_PINYIN @&quot;Hanyu&quot;</span><br><span class="line">#define WADEGILES_PINYIN @&quot;Wade&quot;</span><br><span class="line">#define MPS2_PINYIN @&quot;MPSII&quot;</span><br><span class="line">#define YALE_PINYIN @&quot;Yale&quot;</span><br><span class="line">#define TONGYONG_PINYIN @&quot;Tongyong&quot;</span><br><span class="line">#define GWOYEU_ROMATZYH @&quot;Gwoyeu&quot;</span><br><span class="line"></span><br><span class="line">MPS2_PINYIN：注音符号第二式</span><br><span class="line">YALE_PINYIN：耶鲁拼法</span><br><span class="line">HANYU_PINYIN：汉语拼音</span><br><span class="line">TONGYONG_PINYIN：通用拼音</span><br><span class="line">GWOYEU_ROMATZYH：国语罗马字</span><br><span class="line">WADEGILES_PINYIN：威妥玛拼音(威玛拼法)</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> 音调，例：刘</span><br><span class="line"> */</span><br><span class="line">typedef enum &#123;</span><br><span class="line">  ToneTypeWithToneNumber,   // 用数字表示声调，例如：liu2</span><br><span class="line">  ToneTypeWithoutTone,      // 无音调，例如：liu</span><br><span class="line">  ToneTypeWithToneMark      // 用声调符号表示，例如：liú</span><br><span class="line">&#125; ToneType;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> 大小写，例：国</span><br><span class="line"> */</span><br><span class="line">typedef enum &#123;</span><br><span class="line">    CaseTypeUppercase,  // GUÓ</span><br><span class="line">    CaseTypeLowercase   // guó</span><br><span class="line">&#125; CaseType;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> unicode 的ü 、v 和 u时的显示方式，例：吕</span><br><span class="line"> */</span><br><span class="line">typedef enum &#123;</span><br><span class="line">    VCharTypeWithUAndColon, // lu:3</span><br><span class="line">    VCharTypeWithV,         // lv3</span><br><span class="line">    VCharTypeWithUUnicode   // lü3</span><br><span class="line">&#125; VCharType;</span><br></pre></td></tr></table></figure>
<p>前面的代码参考<a href="http://www.cnblogs.com/mthoutai/p/6745293.html" target="_blank" rel="external">java 中文转拼音之pinyin4j</a>。当然，在移动端其实并不会使用太多格式，因此简单介绍，并不作说明。详情可以参见外链的文章。</p>
<h4 id="类"><a href="#类" class="headerlink" title="类"></a>类</h4><p>源代码中就只有几个文件，代码逻辑也不会很复杂。在深入阅读代码之前，需要搞清楚几个文件的作用。接下来简单描述项目中的类：<br></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ChineseToPinyinResource: 拼音转汉字的文件</span><br><span class="line">HanyuPinyinOutputFormat: 输出格式定义</span><br><span class="line">NSString+PinYin4Cocoa: 工具方法转换</span><br><span class="line">PinyinFormatter: 按照输出格式，格式化返回字符</span><br><span class="line">PinyinHelper: 开源库的使用方法文件</span><br><span class="line">unicode_to_hanyu_pinyin: unicode编码字典文件（每个汉字，对应一个unicode编码）</span><br></pre></td></tr></table></figure>
<h3 id="转换思想"><a href="#转换思想" class="headerlink" title="转换思想"></a>转换思想</h3><p>pinyin4objc实际上是参考java当中的pinyin4j。核心思想也非常简单，在我们调用汉字转拼音之时，会生成一个单例对象。单例里面所做的事情就是：从沙盒独出读出unicode字典，如果独处失败，会将unicode_to_hanyu_pinyin文件中的数据读取到字典中，然后再将此字典以二进制的方式将数据缓存在沙盒中，以供以后使用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">- (void)initializeResource &#123;</span><br><span class="line">    </span><br><span class="line">    /*</span><br><span class="line">     1. 首先判断沙盒是否存在，如果沙盒存在则直接使用沙盒数据</span><br><span class="line">     2. 如果沙盒不存在，则读取资源文件数据，最后将资源文件数据通过二进制的方式直接缓存到沙盒</span><br><span class="line">     */</span><br><span class="line">    NSString* cachesDirectory = NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES)[0];</span><br><span class="line">	_directory = [[[cachesDirectory stringByAppendingPathComponent:[[NSBundle mainBundle] bundleIdentifier]] stringByAppendingPathComponent:@&quot;PinYinCache&quot;] copy];</span><br><span class="line">    </span><br><span class="line">    NSFileManager *fileManager = [NSFileManager defaultManager];</span><br><span class="line">    if (![fileManager fileExistsAtPath:_directory]) &#123;</span><br><span class="line">        NSError *error = nil;</span><br><span class="line">        </span><br><span class="line">        if (![fileManager createDirectoryAtPath:_directory withIntermediateDirectories:YES attributes:nil error:&amp;error]) &#123;</span><br><span class="line">            PYLog(@&quot;Error, s is %@, %s, %s, %d&quot;,error.description, __FILE__ ,__FUNCTION__, __LINE__);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    NSDictionary *dataMap = (NSDictionary *)[self cachedObjectForKey:kCacheKeyForUnicode2Pinyin];</span><br><span class="line">    if (dataMap) &#123;</span><br><span class="line">        self-&gt;_unicodeToHanyuPinyinTable = dataMap;</span><br><span class="line">        </span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        </span><br><span class="line">        NSString *resourceName = [[NSBundle mainBundle] pathForResource:@&quot;unicode_to_hanyu_pinyin&quot; ofType:@&quot;txt&quot;];</span><br><span class="line">        NSString *dictionaryText = [NSString stringWithContentsOfFile:resourceName encoding:NSUTF8StringEncoding error:nil];</span><br><span class="line">        NSArray *lines = [dictionaryText componentsSeparatedByString:@&quot;\r\n&quot;];</span><br><span class="line">        </span><br><span class="line">        __block NSMutableDictionary *tempMap=[[NSMutableDictionary alloc] init];</span><br><span class="line">        </span><br><span class="line">        @autoreleasepool &#123;</span><br><span class="line">                [lines enumerateObjectsUsingBlock:^(id obj, NSUInteger idx, BOOL *stop) &#123;</span><br><span class="line">                    NSArray *lineComponents = [obj componentsSeparatedByCharactersInSet:[NSCharacterSet whitespaceCharacterSet]];</span><br><span class="line">                    [tempMap setObject:lineComponents[1] forKey:lineComponents[0]];</span><br><span class="line">                &#125;];</span><br><span class="line">         &#125;</span><br><span class="line">        </span><br><span class="line">        self-&gt;_unicodeToHanyuPinyinTable = tempMap;</span><br><span class="line">        [self cacheObjec:self-&gt;_unicodeToHanyuPinyinTable forKey:kCacheKeyForUnicode2Pinyin];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将中文作为key，从字典中可以得到某种格式的拼音，在使用过程当中，按照自定义格式转换成最终所使用的格式即可。</p>
<h3 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h3><p>由上述代码我们能看到，第一次安装使用是从文件中读取数据，从某种意义上来见，这是比较慢的。</p>
<table>
<thead>
<tr>
<th>字符数</th>
<th>次数</th>
<th>时间(秒)</th>
</tr>
</thead>
<tbody>
<tr>
<td>19440</td>
<td>第一次</td>
<td>0.3546s</td>
</tr>
<tr>
<td>19440</td>
<td>第二次</td>
<td>0.2665s</td>
</tr>
<tr>
<td>19440</td>
<td>第三次</td>
<td>0.2535s</td>
</tr>
<tr>
<td>9</td>
<td>第一次</td>
<td>0.1158s</td>
</tr>
<tr>
<td>9</td>
<td>第二次</td>
<td>0.0010s</td>
</tr>
<tr>
<td>9</td>
<td>第三次</td>
<td>0.0015s</td>
</tr>
</tbody>
</table>
<p>从数据来看，首次加载大概会消耗0.1s的时间加载文件。当然，在实际使用当中，首次消耗时间是可以接受的。</p>
<p>从数据我们能看到，pinyin4objc的转换效率还是非常快的。但是，由于我们使用的是单例模式，单例对象在整个生命周期中持有了拼音文件的dictionary，这也导致这么内存在生命周期内一直存在，此处提出一个疑问。</p>
<h3 id="官方转换"><a href="#官方转换" class="headerlink" title="官方转换"></a>官方转换</h3><p>上述提到了第三方库的转换，再来看看苹果内部是如何转换的呢😀😀😀。在网上找了一段代码，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+ (NSString *)transform:(NSString *)chinese</span><br><span class="line">&#123;</span><br><span class="line">    NSMutableString *pinyin = [chinese mutableCopy];</span><br><span class="line">    CFStringTransform((__bridge CFMutableStringRef)pinyin, NULL, kCFStringTransformMandarinLatin, NO);</span><br><span class="line">    CFStringTransform((__bridge CFMutableStringRef)pinyin, NULL, kCFStringTransformStripCombiningMarks, NO);</span><br><span class="line">    NSLog(@&quot;%@&quot;, pinyin);</span><br><span class="line">    return [pinyin uppercaseString];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试数据如下：</p>
<table>
<thead>
<tr>
<th>字符数</th>
<th>次数</th>
<th>时间(秒)</th>
<th>使用方法</th>
</tr>
</thead>
<tbody>
<tr>
<td>2693 * 100</td>
<td>第一次</td>
<td>5.3802s</td>
<td>苹果内置</td>
</tr>
<tr>
<td>2693 * 100</td>
<td>第二次</td>
<td>5.1389s</td>
<td>苹果内置</td>
</tr>
<tr>
<td>2693 * 100</td>
<td>第三次</td>
<td>4.9573s</td>
<td>苹果内置</td>
</tr>
<tr>
<td>164  * 100</td>
<td>第一次</td>
<td>0.5060s</td>
<td>苹果内置</td>
</tr>
<tr>
<td>164  * 100</td>
<td>第二次</td>
<td>0.4096s</td>
<td>苹果内置</td>
</tr>
<tr>
<td>164  * 100</td>
<td>第三次</td>
<td>0.4152s</td>
<td>苹果内置</td>
</tr>
<tr>
<td>2693 * 100</td>
<td>第一次</td>
<td>1.9244s</td>
<td>pinyin4obj</td>
</tr>
<tr>
<td>2693 * 100</td>
<td>第二次</td>
<td>1.7063s</td>
<td>pinyin4obj</td>
</tr>
<tr>
<td>2693 * 100</td>
<td>第三次</td>
<td>1.6897s</td>
<td>pinyin4obj</td>
</tr>
<tr>
<td>164  * 100</td>
<td>第一次</td>
<td>0.2228s</td>
<td>pinyin4obj</td>
</tr>
<tr>
<td>164  * 100</td>
<td>第二次</td>
<td>0.1340s</td>
<td>pinyin4obj</td>
</tr>
<tr>
<td>164  * 100</td>
<td>第三次</td>
<td>0.1017s</td>
<td>pinyin4obj</td>
</tr>
</tbody>
</table>
<p>从测试数据可以看出，苹果内置转换要比pinyin4objc耗时多3-5倍。因此，在使用过程当中，要尽量考虑出数据量的大小，选择自己需要的解决办法。</p>
<h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>记得曾今在项目中使用过两次汉字转拼音的功能，一次是数据量特别少，因此在使用过程当中完全不知道耗时的事情。接下来就是现在这个项目，测试报了一个bug说大概半分钟才会出现数据，当时也不清楚是什么问题，最后详查了一下，定位是汉字转拼音的问题。真是崩溃啊，当时的解决方案是暂时不使用汉字转拼音，忽略掉耗时的请求了。最近，因为需要做本地搜索，所以很多数据需要，就从新调研了一下汉字转拼音的库。</p>
<p>总体来讲，pinyin4objc的性能还是比较好的，转花效率还是蛮高的。至于占用的内存，算算也还可以接受。因此，还是蛮推荐大家使用的。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/07/19/SDWebImage之SDWebImageDownloader相关/" itemprop="url">
                  SDWebImage之SDWebImageDownloader相关
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-07-19T00:55:29+08:00" content="2016-07-19">
              2016-07-19
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/源码剖析/" itemprop="url" rel="index">
                    <span itemprop="name">源码剖析</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/07/19/SDWebImage之SDWebImageDownloader相关/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/07/19/SDWebImage之SDWebImageDownloader相关/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/07/19/SDWebImage源码之SDImageCache/" itemprop="url">
                  SDWebImage源码之SDImageCache
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-07-19T00:36:26+08:00" content="2016-07-19">
              2016-07-19
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/源码剖析/" itemprop="url" rel="index">
                    <span itemprop="name">源码剖析</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/07/19/SDWebImage源码之SDImageCache/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/07/19/SDWebImage源码之SDImageCache/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>SDImageCache类是实现图片缓存的类，此类的缓存分为两种：磁盘缓存、保留在内存。通俗的说就是前者保存在沙盒，后者停留在内存中。问题在于，沙盒读写比较耗时，保存在内存中比较占内存，可能存在因内存过大而崩溃。对于沙盒读写耗时，如果文件不大，手机读写速度快，那也是毫厘之间的时间就能完成的。内存占有率大，这个苹果的NSCache就给我们提供了相应的方法，可以在一定程度上降低内存占有率和防止应用崩溃，关于NSCache可以看另外一篇文章<a href="http://blog.ysenin.com/2016/07/17/NSCache%E7%9B%B8%E5%85%B3%E8%A7%A3%E8%AF%BB/" target="_blank" rel="external">NSCache相关解读</a>。</p>
<h3 id="缓存类型"><a href="#缓存类型" class="headerlink" title="缓存类型"></a>缓存类型</h3><p>SDImageCache提供了三种枚举类型，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 读取缓存枚举类型</span><br><span class="line">typedef NS_ENUM(NSInteger, SDImageCacheType) &#123;</span><br><span class="line">    SDImageCacheTypeNone, // image不可用于SDWebImage缓存，但可以从网络下载</span><br><span class="line">    SDImageCacheTypeDisk, // 图片可以从磁盘缓存空间获取</span><br><span class="line">    SDImageCacheTypeMemory // 图片从内存空间获取</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>如上，我们读取缓存的时候，可以从网络上下载，从磁盘读区，也可以从内存空间获得。当然，具体是怎样实现由具体的技术实现来完成。</p>
<h3 id="Block"><a href="#Block" class="headerlink" title="Block"></a>Block</h3><p>在SDImageCache中，给我们提供了三个block<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 通过key查询，缓存（内存和磁盘）是否存在缓存，并返回图片数据和缓存来源</span><br><span class="line">typedef void(^SDWebImageQueryCompletedBlock)(UIImage *image, SDImageCacheType cacheType);</span><br><span class="line"></span><br><span class="line">// 检查key是否存在磁盘缓存中</span><br><span class="line">typedef void(^SDWebImageCheckCacheCompletionBlock)(BOOL isInCache);</span><br><span class="line"></span><br><span class="line">// 计算磁盘缓存大小，返回磁盘缓存数目和总大小</span><br><span class="line">typedef void(^SDWebImageCalculateSizeBlock)(NSUInteger fileCount, NSUInteger totalSize);</span><br></pre></td></tr></table></figure></p>
<p>如注释所示，前两个block查询key的缓存数据，第三个block是计算磁盘缓存大小。这几个block在后面的代码实现中有很重要的作用，因此我们做一个重要了解。</p>
<h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 此属性主要用于gif图片类，解压被下载并缓存的图片可以提高性能，但是会消耗很多内存，默认为yes，如果遇到因为内存消耗过大而导致崩溃，可以设置为no</span><br><span class="line"> */</span><br><span class="line">@property (assign, nonatomic) BOOL shouldDecompressImages;</span><br><span class="line"></span><br><span class="line">// 允许iCloud备份，默认为yes</span><br><span class="line">@property (assign, nonatomic) BOOL shouldDisableiCloud;</span><br><span class="line"></span><br><span class="line">// 使用内存缓存，默认yes</span><br><span class="line">@property (assign, nonatomic) BOOL shouldCacheImagesInMemory;</span><br><span class="line"></span><br><span class="line">// 内存中图片最大的缓存花费（最大缓存容量），花费的方法是保留在内存中的像素个数</span><br><span class="line">@property (assign, nonatomic) NSUInteger maxMemoryCost;</span><br><span class="line"></span><br><span class="line">// 最大可以缓存的图片对象</span><br><span class="line">@property (assign, nonatomic) NSUInteger maxMemoryCountLimit;</span><br><span class="line"></span><br><span class="line">// 图片最长缓存时间</span><br><span class="line">@property (assign, nonatomic) NSInteger maxCacheAge;</span><br><span class="line"></span><br><span class="line">// 最大比特缓存</span><br><span class="line">@property (assign, nonatomic) NSUInteger maxCacheSize;</span><br></pre></td></tr></table></figure>
<p>关于属性，事实上和NSCache的属性差不多。这里需要说一下<strong>maxCacheAge</strong>的实现方式。maxCacheAge如注释所示，代表最长的缓存时间，这里仅仅是针对于磁盘缓存而言。maxCacheAge仅仅是一个相对的时间，并不是绝对的。从源码可以看出，磁盘缓存清理会到用到<strong>- (void)cleanDiskWithCompletionBlock:(SDWebImageNoParamsBlock)completionBlock</strong>方法，在此方法，系统会去检索磁盘，是否存在缓存文件，并读出可用路径。之后通过文件最后修改的时间，和离现在maxCacheAge之前的时间节点时间相互比较，判断是否应该删除。那么<strong>重点</strong>在于，在什么地方会调用此方法呢？还是回到源码，如下代码可以发现问题：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">- (id)initWithNamespace:(NSString *)ns diskCacheDirectory:(NSString *)directory &#123;</span><br><span class="line">    if ((self = [super init])) &#123;</span><br><span class="line">        /* 各种初始化 */</span><br><span class="line">        // 程序受到内存警告，需要进行内存缓存清理</span><br><span class="line">        [[NSNotificationCenter defaultCenter] addObserver:self</span><br><span class="line">                                                 selector:@selector(clearMemory)</span><br><span class="line">                                                     name:UIApplicationDidReceiveMemoryWarningNotification</span><br><span class="line">                                                   object:nil];</span><br><span class="line"></span><br><span class="line">        // 程序即将被终止（被杀死）,清理磁盘缓存</span><br><span class="line">        [[NSNotificationCenter defaultCenter] addObserver:self</span><br><span class="line">                                                 selector:@selector(cleanDisk)</span><br><span class="line">                                                     name:UIApplicationWillTerminateNotification</span><br><span class="line">                                                   object:nil];</span><br><span class="line"></span><br><span class="line">        // 程序进入后台后，需要清理的磁盘缓存</span><br><span class="line">        [[NSNotificationCenter defaultCenter] addObserver:self</span><br><span class="line">                                                 selector:@selector(backgroundCleanDisk)</span><br><span class="line">                                                     name:UIApplicationDidEnterBackgroundNotification</span><br><span class="line">                                                   object:nil];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从上面代码，我们在新建缓存类的时候注册了三个监听事件。从后面两个监听我们可以看到程序在即将被终止是会调用一次磁盘清理，在程序进入后台需要清理一次。假如程序长时间留在前台，且不被杀死，超过了maxCacheAge时间，缓存磁盘文件还是可能存在于磁盘的。这也就是为啥，说磁盘maxCacheAge是相对的。</p>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>针对SDImageCache的方法，这里只会给出几个重要的方法实现，因为其它都是针对于这几个方法，通过不同的参数形成的。首先缓存很重要的一个东西就是key，这个就是图片的url，由于直接存储url不是特别聪明的办法，因此作者将url转换成了md5编码，取其16进制的编码作为最终的key。然后，磁盘缓存一般都是异步读写。</p>
<h4 id="磁盘存储"><a href="#磁盘存储" class="headerlink" title="磁盘存储"></a>磁盘存储</h4><p>磁盘存储都会统一调用下面这两个方法的代码，具体的可以结合源代码和注释来看，这会让你在读代码时事半功倍。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">// 缓存图片（image，是否从新计算，图片数据，key，是否磁盘缓存）</span><br><span class="line">- (void)storeImage:(UIImage *)image recalculateFromImage:(BOOL)recalculate imageData:(NSData *)imageData forKey:(NSString *)key toDisk:(BOOL)toDisk &#123;</span><br><span class="line">    if (!image || !key) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    // 如果允许内存缓存</span><br><span class="line">    if (self.shouldCacheImagesInMemory) &#123; // 内存缓存</span><br><span class="line">        NSUInteger cost = SDCacheCostForImage(image);</span><br><span class="line">        [self.memCache setObject:image forKey:key cost:cost]; // 跳至内存缓存的方法</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (toDisk) &#123; // 进行异步磁盘缓存</span><br><span class="line">        dispatch_async(self.ioQueue, ^&#123;</span><br><span class="line">            NSData *data = imageData;</span><br><span class="line"></span><br><span class="line">            if (image &amp;&amp; (recalculate || !data)) &#123;</span><br><span class="line">#if TARGET_OS_IPHONE // 是否是iOS平台</span><br><span class="line">                </span><br><span class="line">                int alphaInfo = CGImageGetAlphaInfo(image.CGImage); // 获取图片的通道信息</span><br><span class="line">                BOOL hasAlpha = !(alphaInfo == kCGImageAlphaNone ||</span><br><span class="line">                                  alphaInfo == kCGImageAlphaNoneSkipFirst ||</span><br><span class="line">                                  alphaInfo == kCGImageAlphaNoneSkipLast);</span><br><span class="line">                BOOL imageIsPng = hasAlpha; // 是否有alpha通道</span><br><span class="line"></span><br><span class="line">                // But if we have an image data, we will look at the preffix</span><br><span class="line">                if ([imageData length] &gt;= [kPNGSignatureData length]) &#123; // 判断数据的前8个字节，以确定使用哪种转换方式</span><br><span class="line">                    imageIsPng = ImageDataHasPNGPreffix(imageData);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                if (imageIsPng) &#123; // png 格式</span><br><span class="line">                    data = UIImagePNGRepresentation(image);</span><br><span class="line">                &#125;</span><br><span class="line">                else &#123;</span><br><span class="line">                    data = UIImageJPEGRepresentation(image, (CGFloat)1.0);</span><br><span class="line">                &#125;</span><br><span class="line">#else</span><br><span class="line">                data = [NSBitmapImageRep representationOfImageRepsInArray:image.representations usingType: NSJPEGFileType properties:nil];</span><br><span class="line">#endif</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            [self storeImageDataToDisk:data forKey:key]; // 通过key进行磁盘缓存</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 磁盘缓存，通过key</span><br><span class="line">- (void)storeImageDataToDisk:(NSData *)imageData forKey:(NSString *)key &#123;</span><br><span class="line">    </span><br><span class="line">    if (!imageData) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 判断磁盘缓存路径是否存在，若不存在则创建磁盘缓存路径</span><br><span class="line">    if (![_fileManager fileExistsAtPath:_diskCachePath]) &#123;</span><br><span class="line">        [_fileManager createDirectoryAtPath:_diskCachePath withIntermediateDirectories:YES attributes:nil error:NULL];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // get cache Path for image key</span><br><span class="line">    // 缓存文件路径</span><br><span class="line">    NSString *cachePathForKey = [self defaultCachePathForKey:key]; // md5之后的url</span><br><span class="line">    // transform to NSUrl</span><br><span class="line">    // 转换成nsurl</span><br><span class="line">    NSURL *fileURL = [NSURL fileURLWithPath:cachePathForKey];</span><br><span class="line">    </span><br><span class="line">    // 创建缓存文件</span><br><span class="line">    [_fileManager createFileAtPath:cachePathForKey contents:imageData attributes:nil];</span><br><span class="line">    </span><br><span class="line">    // disable iCloud backup</span><br><span class="line">    // 启用iCloud备份</span><br><span class="line">    if (self.shouldDisableiCloud) &#123;</span><br><span class="line">        [fileURL setResourceValue:[NSNumber numberWithBool:YES] forKey:NSURLIsExcludedFromBackupKey error:nil];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="磁盘查找"><a href="#磁盘查找" class="headerlink" title="磁盘查找"></a>磁盘查找</h4><p>磁盘查找需要注意一点的就是，在文件存储的时候，可能存在没有后缀扩展名的存在，因此需要检查两次，依次是存在扩展名，一次是不存在扩展名。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">// 判断磁盘文件是否存在key的缓存文件</span><br><span class="line">- (BOOL)diskImageExistsWithKey:(NSString *)key &#123;</span><br><span class="line">    BOOL exists = NO;</span><br><span class="line">    </span><br><span class="line">    // 这是期望通过连接文件管理在其他的io队列，但是我们使用了单例,来自苹果官方文档的解释是：文件管理的单例对象方法，在多线程能安全的调用。</span><br><span class="line">    </span><br><span class="line">    // 通过key获取缓存文件路径</span><br><span class="line">    exists = [[NSFileManager defaultManager] fileExistsAtPath:[self defaultCachePathForKey:key]];</span><br><span class="line"></span><br><span class="line">    // 根据https://github.com/rs/SDWebImage/pull/976，可能key添加了后缀扩展名,因此需要判断key是否存在后缀扩展名</span><br><span class="line">    if (!exists) &#123;</span><br><span class="line">        // key存在后缀，需要删除扩展名，只保留文件名</span><br><span class="line">        exists = [[NSFileManager defaultManager] fileExistsAtPath:[[self defaultCachePathForKey:key] stringByDeletingPathExtension]];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return exists;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 方法作用同上，只是实现了异步判断，添加回调block</span><br><span class="line">- (void)diskImageExistsWithKey:(NSString *)key completion:(SDWebImageCheckCacheCompletionBlock)completionBlock &#123;</span><br><span class="line">    dispatch_async(_ioQueue, ^&#123;</span><br><span class="line">        BOOL exists = [_fileManager fileExistsAtPath:[self defaultCachePathForKey:key]];</span><br><span class="line"></span><br><span class="line">        if (!exists) &#123;</span><br><span class="line">            exists = [_fileManager fileExistsAtPath:[[self defaultCachePathForKey:key] stringByDeletingPathExtension]];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 异步结束，执行回调</span><br><span class="line">        if (completionBlock) &#123;</span><br><span class="line">            dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                completionBlock(exists);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="磁盘删除"><a href="#磁盘删除" class="headerlink" title="磁盘删除"></a>磁盘删除</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">- (void)removeImageForKey:(NSString *)key fromDisk:(BOOL)fromDisk withCompletion:(SDWebImageNoParamsBlock)completion &#123;</span><br><span class="line">    </span><br><span class="line">    if (key == nil) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 从内存删除gif数据</span><br><span class="line">    if (self.shouldCacheImagesInMemory) &#123;</span><br><span class="line">        [self.memCache removeObjectForKey:key];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (fromDisk) &#123;</span><br><span class="line">        dispatch_async(self.ioQueue, ^&#123; // 异步队列</span><br><span class="line">            // 删除路径下的数据</span><br><span class="line">            [_fileManager removeItemAtPath:[self defaultCachePathForKey:key] error:nil];</span><br><span class="line">            </span><br><span class="line">            if (completion) &#123;</span><br><span class="line">                dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                    completion();</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; else if (completion)&#123;</span><br><span class="line">        completion();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="内存缓存"><a href="#内存缓存" class="headerlink" title="内存缓存"></a>内存缓存</h4><p>SDImageCache两种缓存方式：磁盘缓存、内存缓存。上面介绍了磁盘缓存的一些读写的重要方法，那么内存缓存SDImageCache则是使用了NSCache的方式去完成的。因此，如果想学习NSCache可以看我另外一篇文章，也可以自己百度，那一块儿就不再深入探究了。</p>
<h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>至此，关于SDImageCache的讲解就到此结束了。上面存在的源码比较多，当然也有一定的文字描述。里面提到了一些重要的知识点，还望细细品尝，如果有啥问题可以留言给我。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/07/17/NSCache相关解读/" itemprop="url">
                  NSCache相关解读
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-07-17T01:47:52+08:00" content="2016-07-17">
              2016-07-17
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Foundation/" itemprop="url" rel="index">
                    <span itemprop="name">Foundation</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/07/17/NSCache相关解读/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/07/17/NSCache相关解读/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>说实话，最近在看SDWebImage，里面很重要的一部分就是讲缓存这个知识点。那么，写这篇文章的前半个小时，是准备写SDWebImage的源码分析的。但因为强迫症，觉得需要讲清楚缓存相关的概念，才能继续往下讲SDWebImage。因此，这篇文章，主要讲NSCache相关的知识点，以及其他方式构建缓存的优缺点。</p>
<h3 id="NSCache介绍与基本使用"><a href="#NSCache介绍与基本使用" class="headerlink" title="NSCache介绍与基本使用"></a>NSCache介绍与基本使用</h3><p>这是一个非常简单的缓存管理类，以key-value对的形式进行存储。是不是感觉和NSMutableDictionary非常相似呢？没错，在iOS 4之前，苹果就是以NSMutableDictionary的形势做缓存的，至于两者的区别会在接下来的文章里提到。在项目中，新建一个NSCache对象，点击进入NSCache类中，我们就可以看到NSCache给我们提供的几个简单的属性和方法。</p>
<h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><blockquote>
<p>@property (copy) NSString *name; // 名称<br>@property (nullable, assign) id<nscachedelegate> delegate; // 代理<br>@property NSUInteger totalCostLimit;    // 最大缓存容量上限<br>@property NSUInteger countLimit;    // 最大缓存容量对象个数<br>@property BOOL evictsObjectsWithDiscardedContent; // 是否允许退出对象丢弃缓存内容</nscachedelegate></p>
</blockquote>
<p>这里需要重点讲的只有totalCostLimit和countLimit两个属性，如注释所看到的，一个是最大缓存容量上限和最大缓存对象个数。</p>
<blockquote>
<p>  1.totalCostLimit：默认为0，表示没有最大的缓存上限；当不为0时，我们在添加的缓存数据超过totalCostLimit，NSCache会自动帮我们移除一个或多个缓存对象，以保证我们添加缓存数据之后的大小不会超过最大的缓存容量。<br>  2.countLimit: 默认为0，表示没有最大的缓存上限个数；当不为0时，我们逐个添加缓存时，会计算是否超过最大的缓存数量个数，若超过则会自动释放其中一个。</p>
</blockquote>
<p>当然，上面两个属性并不是一个严格的限制。当缓存数据超过限制时，可能会立即丢弃、稍后或者永不丢弃，具体的得看具体的实现细节。</p>
<h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><p>NSCache提供了一组方法来存取key－value对，通过下面的方法就可以设置缓存数据。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (nullable <span class="type">ObjectType</span>)objectForKey:(<span class="type">KeyType</span>)key; <span class="comment">// 获取key的缓存数据</span></span><br><span class="line">- (void)setObject:(<span class="type">ObjectType</span>)obj forKey:(<span class="type">KeyType</span>)key; <span class="comment">// 0 cost, 设置key的缓存数据，默认缓存花费为0</span></span><br><span class="line">- (void)setObject:(<span class="type">ObjectType</span>)obj forKey:(<span class="type">KeyType</span>)key cost:(<span class="type">NSUInteger</span>)g; <span class="comment">// 同上，缓存花费为g</span></span><br><span class="line">- (void)removeObjectForKey:(<span class="type">KeyType</span>)key; <span class="comment">// 移除key的缓存数据</span></span><br><span class="line">- (void)removeAllObjects; <span class="comment">// 移除所有缓存数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// delegate</span></span><br><span class="line">- (void)cache:(<span class="type">NSCache</span> *)cache willEvictObject:(id)obj; <span class="comment">// 被移除的缓存数据对象</span></span><br></pre></td></tr></table></figure></p>
<p>特别需要说明的两个方法如下：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (void)setObject:(<span class="type">ObjectType</span>)obj forKey:(<span class="type">KeyType</span>)key; <span class="comment">// 方法一</span></span><br><span class="line">- (void)setObject:(<span class="type">ObjectType</span>)obj forKey:(<span class="type">KeyType</span>)key cost:(<span class="type">NSUInteger</span>)g; <span class="comment">// 方法二</span></span><br></pre></td></tr></table></figure></p>
<p>本质上，两个方法的实现是一样的，方法一的cost默认为0。那么cost时用来干什么的呢？参考<a href="http://southpeak.github.io/blog/2015/02/11/cocoa-foundation-nscache/" target="_blank" rel="external">南峰子的技术博客</a>有如下这段话：</p>
<blockquote>
<p>这个消耗值用于计算缓存中所有对象的一个消耗总和。当内存受限或者总消耗超过了限定的最大总消耗，则缓存应该开启一个丢弃过程以移除一些对象。不过，这个过程不能保证被丢弃对象的顺序。其结果是，如果我们试图操作这个消耗值来实现一些特殊的行为，则后果可能会损害我们的程序。通常情况下，这个消耗值是对象的字节大小。如果这些信息不是现成的，则我们不应该去计算它，因为这样会使增加使用缓存的成本。如果我们没有可用的值传递，则直接传递0，或者是使用-setObject:forKey:方法，这个方法不需要传入一个消耗值.</p>
</blockquote>
<p>至于其它方法嘛，都很容易理解，代理方法是NSCache在计算超过最大消耗值时，所移除的对象。</p>
<h3 id="NSCache代码实现"><a href="#NSCache代码实现" class="headerlink" title="NSCache代码实现"></a>NSCache代码实现</h3><p>事实上，NSCache在以前是不知道内部实现。但现在不一样了，由于Swift现在开源，我们可以通过Swift去探查NSCache的具体实现。<a href="https://github.com/apple/swift-corelibs-foundation/blob/master/Foundation/NSCache.swift" target="_blank" rel="external">NSCache源码</a>，从源码可以看出。NSCache的底层实现，是一个双向链表。但是感觉源码存在一个bug，不知道具体是怎样子的。撇开这些bug，我们看一下关于最大的缓存内存容量和最大的缓存个数。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">insert</span><span class="params">(<span class="number">_</span> entry: NSCacheEntry)</span></span> &#123; <span class="comment">// 添加缓存数据</span></span><br><span class="line">    <span class="keyword">if</span> _byCost == <span class="literal">nil</span> &#123;</span><br><span class="line">        _byCost = entry</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> element = _byCost</span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">let</span> e = element &#123; <span class="comment">// 计算需要存放在链表的位置</span></span><br><span class="line">            <span class="keyword">if</span> e.cost &gt; entry.cost &#123;</span><br><span class="line">                <span class="keyword">let</span> newPrev = e.prevByCost</span><br><span class="line">                entry.prevByCost = newPrev</span><br><span class="line">                entry.nextByCost = e <span class="comment">// bug，应该添加e.prevByCost = entry</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">            element = e.nextByCost</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">setObject</span><span class="params">(<span class="number">_</span> obj: AnyObject, forKey key: AnyObject, cost g: Int)</span></span> &#123;</span><br><span class="line">    <span class="keyword">let</span> keyRef = <span class="built_in">unsafeBitCast</span>(key, to: <span class="type">UnsafePointer</span>&lt;<span class="type">Void</span>&gt;.<span class="keyword">self</span>) <span class="comment">// 获取key的指针</span></span><br><span class="line">    </span><br><span class="line">    _lock.lock()</span><br><span class="line">    _totalCost += g <span class="comment">// 计算当前所缓存的统计</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> purgeAmount = <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> totalCostLimit &gt; <span class="number">0</span> &#123;</span><br><span class="line">        purgeAmount = (_totalCost + g) - totalCostLimit <span class="comment">// 需要移除的内存大小</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> purgeCount = <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> countLimit &gt; <span class="number">0</span> &#123;</span><br><span class="line">        purgeCount = (_entries.<span class="built_in">count</span> + <span class="number">1</span>) - countLimit <span class="comment">// 需要移除的对象个数</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> entry = _entries[keyRef] &#123;</span><br><span class="line">        entry.value = obj <span class="comment">// 如果key已经存在，则会替换掉</span></span><br><span class="line">        <span class="keyword">if</span> entry.cost != g &#123; <span class="comment">// 更新cost</span></span><br><span class="line">            entry.cost = g</span><br><span class="line">            remove(entry)</span><br><span class="line">            insert(entry)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        _entries[keyRef] = <span class="type">NSCacheEntry</span>(key: key, value: obj, cost: g)</span><br><span class="line">    &#125;</span><br><span class="line">    _lock.unlock() <span class="comment">// 解锁</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> toRemove = [<span class="type">NSCacheEntry</span>]() <span class="comment">// 需要移除的对象实例</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> purgeAmount &gt; <span class="number">0</span> &#123; <span class="comment">// 需要丢弃缓存的数量</span></span><br><span class="line">        _lock.lock()</span><br><span class="line">        <span class="keyword">while</span> _totalCost - totalCostLimit &gt; <span class="number">0</span> &#123; <span class="comment">// 由于链表有序，所以从第一个开始抛弃，直到总缓存大小小于设定的缓存大小</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> entry = _byCost &#123;</span><br><span class="line">                _totalCost -= entry.cost</span><br><span class="line">                toRemove.append(entry)</span><br><span class="line">                remove(entry)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> countLimit &gt; <span class="number">0</span> &#123;</span><br><span class="line">            purgeCount = (_entries.<span class="built_in">count</span> - toRemove.<span class="built_in">count</span>) - countLimit <span class="comment">// 更新当前缓存的对象个数</span></span><br><span class="line">        &#125;</span><br><span class="line">        _lock.unlock()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> purgeCount &gt; <span class="number">0</span> &#123;</span><br><span class="line">        _lock.lock()</span><br><span class="line">        <span class="keyword">while</span> (_entries.<span class="built_in">count</span> - toRemove.<span class="built_in">count</span>) - countLimit &gt; <span class="number">0</span> &#123; <span class="comment">// 当未超过最大缓存大小，但超过最大的缓存个数，做移除操作</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> entry = _byCost &#123;</span><br><span class="line">                _totalCost -= entry.cost</span><br><span class="line">                toRemove.append(entry)</span><br><span class="line">                remove(entry)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        _lock.unlock()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> del = delegate &#123; <span class="comment">// 代理方法，释放的对象</span></span><br><span class="line">        <span class="keyword">for</span> entry <span class="keyword">in</span> toRemove &#123;</span><br><span class="line">            del.cache(<span class="keyword">self</span>, willEvictObject: entry.value)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    _lock.lock()</span><br><span class="line">    <span class="keyword">for</span> entry <span class="keyword">in</span> toRemove &#123;</span><br><span class="line">        _entries.removeValue(forKey: <span class="built_in">unsafeBitCast</span>(entry.key, to: <span class="type">UnsafePointer</span>&lt;<span class="type">Void</span>&gt;.<span class="keyword">self</span>)) <span class="comment">// the cost list is already fixed up in the purge routines, 移除释放的对象</span></span><br><span class="line">    &#125;</span><br><span class="line">    _lock.unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>通过上面的代码，可以看到NSCache是按照对象容量进行排序的。在超过最大缓存设定时，是从容量从小到大的移除，这也就解决了之前不知道具体实现的而不知道移除的对象。当然，现在虽然知道移除的是谁，但是需要计算出来还是需要一定时耗的。</p>
<h3 id="NSCache和可变集合的区别"><a href="#NSCache和可变集合的区别" class="headerlink" title="NSCache和可变集合的区别"></a>NSCache和可变集合的区别</h3><p>接下来这段是摘抄自<a href="http://southpeak.github.io/blog/2015/02/11/cocoa-foundation-nscache/" target="_blank" rel="external">南峰子的技术博客</a>，总结的东西在很多关于NSCache的文章都可以看到。当然，还介绍各位可以看一下[Effective Objective-C 2.0 编写高质量的iOS和OS X代码的52个有效方法]</p>
<blockquote>
<p>1.NSCache类结合了各种自动删除策略，以确保不会占用过多的系统内存。如果其它应用需要内存时，系统自动执行这些策略。当调用这些策略时，会从缓存中删除一些对象，以最大限度减少内存的占用<br>2.NSCache是线程安全的，我们可以在不同的线程中添加、删除和查询缓存中的对象，而不需要锁定缓存区域<br>3.不像NSMutableDictionary对象，一个缓存对象不会拷贝key对象</p>
</blockquote>
<h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>NSCache是一个很简单的缓存框架，方法简单，源代码也比较简单。通过Swift中关于NSCache的源码，可以更好的理解缓存策略。也很建议各位在学习知识点的时候，深入去学习，这样对于缓存的理解就不仅仅局限在在于调用代码的基础上。</p>
<p>参考文献：<br>1.<a href="http://southpeak.github.io/blog/2015/02/11/cocoa-foundation-nscache/" target="_blank" rel="external">南峰子的技术博客</a><br>2.<a href="https://github.com/nixzhu/dev-blog/blob/master/2015-12-09-nscache.md" target="_blank" rel="external">nixzhu/dev-blog</a><br>3.<a href="http://www.jianshu.com/p/2fad7265317e" target="_blank" rel="external">feiyangkl的简书</a><br>4.<a href="http://nshipster.cn/nscache/" target="_blank" rel="external">NSCache</a><br>4.[Effective Objective-C 2.0 编写高质量的iOS和OS X代码的52个有效方法] Matt Galloway著 爱飞翔 译</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/07/17/SDWebImage-源码剖析/" itemprop="url">
                  SDWebImage 源码剖析
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-07-17T00:59:11+08:00" content="2016-07-17">
              2016-07-17
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/源码剖析/" itemprop="url" rel="index">
                    <span itemprop="name">源码剖析</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/07/17/SDWebImage-源码剖析/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/07/17/SDWebImage-源码剖析/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>吐槽一下，前段时间准备面试，然后在拉勾透了各种公司，估摸着又一个月吧，得到一个面试机会。还没把握住，跪在了第四面。不知道怎么言表自己这份心情，大概有如下几个原因吧：</p>
<blockquote>
<p>1.个人能力问题，这也算是最大的问题，虽然基础还过得去，但是项目经验少，知识面比较窄；<br>2.单纯的移动互联网威风不再，iOS市场过剩，现在都是择优录取，经验都是3－5年，我这一年的有点尴尬；<br>3.投递的公司，大多数是比较大型的公司，因此从项目经验和学校就给筛选掉了；<br>4.招聘高峰期过了，公司现在不怎么缺新人；<br>5.拉勾的机制问题，不知道是不是啊。上一家面试公司，那天上午给我发了面试邀请，结果下午拉勾就给我发了一条不匹配的邮件。</p>
</blockquote>
<p>然后呢，在这段时间疯狂的补基础，什么iOS基础、计算机网络、leetcode刷题、操作系统之类的。每天下班回来，就开始看各种东西。晕、晕、晕……不过投了这么久还是没有面试机会，尴尬啊。</p>
<p>好了，吐槽完了。说一下iOS学习吧，很多时候呢，我们学完基础知识就不知道怎么深入学习了，那研究源码算是一个深入学习知识的不错选择。至于SDWebImage这个框架呢，在网上已经有很多这方面的文章了。虽然都是千篇一律，但对于没有读过源码的人来讲，看那些文章就比较吃力了。本文，也仅仅是纪录我在读SDWebImage源码时，对此框架的一些理解吧。</p>
<h3 id="SDWebImage解读"><a href="#SDWebImage解读" class="headerlink" title="SDWebImage解读"></a>SDWebImage解读</h3><p>SDWebImage是一个下载兼缓存的第三方常用框架，框架整体来讲分为两大块：异步下载和缓存。异步下载主要利用NSOperationQueue和NSURLSession来完成实现的，缓存分为磁盘缓存和内存缓存两种，具体的实现，会在接下来的文章中会慢慢分析。整个框架主要包含知识点有：NSOperation、NSOperationQueue、NSURLSession、GCD、NSCache和Runtime来实现的，通过categories的方式添加到我们常用的View中。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/07/05/记一次面试经历/" itemprop="url">
                  记一次面试经历
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-07-05T13:55:50+08:00" content="2016-07-05">
              2016-07-05
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/面试经历/" itemprop="url" rel="index">
                    <span itemprop="name">面试经历</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/07/05/记一次面试经历/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/07/05/记一次面试经历/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>距离毕业刚好一年，那么这一年呢！换了两个公司，第一个由于内部股权争端，还没有到两个月就已经夭折（很恶心）；然后来到了第二个公司，也就是现在这个公司。在这个公司呢，待着是没啥问题，正常的编码工作，不算忙。好一点的就是能接触swift开发，算是这一年来最开心的事。问题在于，没人带，平时的相互探讨又少，工资稍低。还有个重要的原因就是：眼更瞎、腰痛、鼠标手、啤酒肚，在这一年内都一一发生了（看来应该买本《程序员健康指南》）,这些谋生了我想离开本公司的想法。所以，在上个月就开始准备去面试。</p>
<p>在拉勾投了半个月，然后收到了一份面试邀请。第一个星期的简历写的太简单，当然第二份也差不多。在面试完才发现，其实在这一年做过的项目是没有什么技术深度的。所以，导致投了很多简历都没人给机会。所以，非常感谢给机会面试的这家公司<a href="https://www.futu5.com/" target="_blank" rel="external">富途</a>，公司大多数都是腾讯出来的员工，也拿到了腾讯的投资，非常不错的一家公司。</p>
<h3 id="面试过程"><a href="#面试过程" class="headerlink" title="面试过程"></a>面试过程</h3><p>面试时间是7.4号，由于之前预约的是15点面试，所以早上我从珠海赶车去深圳。到了深圳吃完饭，差不多14:20，也没事做就早点到了公司。进门的感受挺不错，和前台沟通了一下。然后，就等着面试官开始面试。</p>
<h4 id="一面"><a href="#一面" class="headerlink" title="一面"></a>一面</h4><p>基本上的面试流程都是先自我介绍，介绍完之后，就开始针对简历中的项目开始提问。首先，根据我的项目开始问项目遇到的技术难点、是否有看过第三方框架的源码、GCD等。待我回答完之后，可以从他的表情和言语中看出，表现的不是特别好（很差）。然后，在看到我的简历写了关于我在学校学过一些算法，就拿了一份试题给我做。试题内容是关于：指针、字节对齐、数据库等问题；还有4道手写代码題（具体的不能透露，因为公司花了很多时间在这个上面），建议面试可以看<a href="http://blog.csdn.net/v_JULY_v" target="_blank" rel="external">算法之道 结构之法</a>的博客，也可以访问<a href="https://www.julyedu.com/" target="_blank" rel="external">7月在线</a>，博主现在开始创业，所以可以支持下。庆幸的是，自己还没忘记当时学过的知识，大部分都是自己遇到的，也很快得出了结果。当然，也有一些小问题错了，在面试官的指引下逐步完成了最后的代码。</p>
<p>那么在算法这块，自我感觉还算好，毕竟曾今奋斗的东西，虽然并没有取得好的成果。在面试中，和面试官沟通的也很顺畅，面了应该有1个小时吧（当时没怎么看手机）。面试完之后，面试官给出了两个职位iMac开发、iOS开发，问我是不是只做iOS开发。这个嘛，当然不是啊，多学一门技艺总是不错的，恰好有机会，那么不会那么倔强。接着，问我有没有什么要了解的。我大概说了下，自己从学iOS之后开始就是一直自学的，即使在现在这家公司，也没怎么和leader深入探讨iOS相关的属性已经深入的知识等（小公司的悲哀，能做出效果就可以了）。面试官也很用心的给我介绍了，关于公司团队的发展和培养，简而言之就是有人带，每一两周有分享会或者review。很明显，这是符合我的要求。</p>
<p>然后，面试官让我等第二位面试官来面试。隐约可以看出，这应该是iOS的主管。</p>
<h4 id="二面"><a href="#二面" class="headerlink" title="二面"></a>二面</h4><p>这轮面试和第一轮面试差不多，简单介绍自己，稍微问了下项目的东西，应该和一面面试官说了下我的情况（iOS不算很好，算法还过得去）。然后拿了一份逻辑题（一张图，找出其中的重要信息，并回答问题）给我做，大概5分钟。一开始有点懵逼，但细下心来还是可以抽离出其中的重要信息，错了两道（一题是看漏重要信息，另外一题是有点争议吧，个人觉得）。探讨的过程中，讲述了原因，证明这并是不猜的。</p>
<p>这份逻辑题，主要考察观察能力和逻辑思维能力。至于，在实际的项目中有没有帮助呢？那就见仁见智了（同样，不会给出那种图，见谅）。接着，这轮面试官也给了份面试题，主要包括：数学概率、数据结构、操作系统、计算机网络、数据库和一道数独。由于，很久没有接触过上面的这些问题，有几道题就比较犹豫。至于数独嘛，我平时就喜欢玩这个，自然不会有太大问题。</p>
<p>最后，和面试官讨论了关于几道错误题目的问题。有一些，可能是忘了概念，然后做错。有一些，是直接就忘记只是点了。不过，沟通起来还算可以。</p>
<h4 id="三面"><a href="#三面" class="headerlink" title="三面"></a>三面</h4><p>三面是CTO面试，由于二面时，面试官去开会了，花了比较长的时间。CTO面也是等了比较久，不过还算好（CTO都比较忙，能抽出的时间不多），在HR、一面面试官和CTO协商下，决定面试完毕。等了一段时间，HR带领我去CTO办公司，这期间，比较开心的是一面面试官拿了一些面包给我，非常 nice。到了CTO办公室，又是一次自我介绍。然后，问了一些平时不会遇到的问题。具体的知识点如下（还是不会说原题）：</p>
<blockquote>
<p>第一题：for的不同形式实现；<br>第二题：宏定义<br>第三题：概率<br>第四题：某个算法</p>
</blockquote>
<p>对于第一个问题，花了比较长的时间，总是怀疑自己会不会for循环。感觉自己没有问题，CTO每次看了之后，都说有问题再改。最后，在梳理for循环执行的顺序的时候，面试官的语句话提醒了自己，真是一语惊醒梦中人，当头一喝。好吧，还是自己坑，此时感觉不妙，有点悬了。<br>第二题宏定义，也花了很多时间。宏定义在使用的时候，是替换原有的代码。而不是拿宏定义内部的结果去做计算，在编码的过程中是很值得注意的。那么扩展阅读：const、#import和#define的区别<br>第三题，花了比较长的时间，改改改，数学概率题。<br>第四题算法题，这个嘛，讲思想，遇到了就知道。</p>
<p>整个CTO面试的过程都是懵的，从第一个问题开始，CTO的安静和一眼抓住重要点的气场让我真心hold不住。不过，在CTO面试结束之后，和一面面试官聊天的时候说CTO是个非常厉害的人。好吧，也算感受到技术大拿的气场了。在上面的问题问完之后，主要了解了一下怎么学习知识，在哪学习和掌握的技能，这些问题也因为前面的问题受到影响而没有怎么回答好。感觉更加悬了，心头坠了一块石头，拉不上去，掉不下来。</p>
<p>面试完毕已经19:30了，好吧，带着一脸忐忑的心和懵逼的脸，涌进在川流不息的人流中，消失在璀璨的霓虹灯的喧嚣世界里……</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>整个面试过程，可以发现iOS的基础掌握不够，学习的知识深度不够。仅仅停留在调用API的层面，没有深入了解iOS的技术等。对于基础的算法、数据结构、计算机网络和操作系统的知识忘的比较快。没有怎么去复习，这个算是一大弊端。不过，通过这次面试，可以知晓自己的技术停留的阶段，在深入学习的道路上，知道自己应该弥补的方向。好了，最后，不管有没有offer，就算是一次检视自己的经历吧。</p>
<h3 id="安利"><a href="#安利" class="headerlink" title="安利"></a>安利</h3><blockquote>
<p>我们的生命，有的时候会是泥沙，你可能慢慢地就会像泥沙一样，沉淀下去了，一旦你沉淀下去了，也许你不用再为了前进而努力了，但是你却永远见不到阳光了。所以我建议大家，不管你现在的生命是怎样的，一定要有水的精神，像水一样不断的积蓄自己地力量，不断的冲破障碍，当你发现时机不到的和时候，把自己的厚度给积累起来，当有一天时机来临的时候，你就能够奔腾入海，成就自己的生命！ – 俞敏洪《赢在中国》</p>
</blockquote>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/07/05/iOS之weak-strong-dance/" itemprop="url">
                  iOS之weak-strong dance
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-07-05T13:30:27+08:00" content="2016-07-05">
              2016-07-05
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/07/05/iOS之weak-strong-dance/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/07/05/iOS之weak-strong-dance/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a href="http://www.jianshu.com/p/0f28c1bead3e" target="_blank" rel="external">weak-strong dance</a><br><a href="http://sherlockyao.com/blog/2015/08/08/weakself-and-strongself-in-blocks/" target="_blank" rel="external">weak-strong dance</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/07/01/学习资料汇总/" itemprop="url">
                  学习资料汇总
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-07-01T15:12:25+08:00" content="2016-07-01">
              2016-07-01
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/学习资料/" itemprop="url" rel="index">
                    <span itemprop="name">学习资料</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/07/01/学习资料汇总/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/07/01/学习资料汇总/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <table>
<thead>
<tr>
<th>归属</th>
<th>博客</th>
<th>添加时间</th>
</tr>
</thead>
<tbody>
<tr>
<td>Swift</td>
<td><a href="https://github.com/linkedin/swift-style-guide" target="_blank" rel="external">LinkedIn Swift Style Guide</a></td>
<td>2016-7-1</td>
</tr>
<tr>
<td>iOS面试心经</td>
<td><a href="https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01%E3%80%8A%E6%8B%9B%E8%81%98%E4%B8%80%E4%B8%AA%E9%9D%A0%E8%B0%B1%E7%9A%84iOS%E3%80%8B%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%82%E8%80%83%E7%AD%94%E6%A1%88/%E3%80%8A%E6%8B%9B%E8%81%98%E4%B8%80%E4%B8%AA%E9%9D%A0%E8%B0%B1%E7%9A%84iOS%E3%80%8B%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%82%E8%80%83%E7%AD%94%E6%A1%88%EF%BC%88%E4%B8%8A%EF%BC%89.md" target="_blank" rel="external">招聘一个靠谱的 iOS</a></td>
<td>2016-7-5</td>
</tr>
</tbody>
</table>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/06/29/关于单例模式的思考/" itemprop="url">
                  关于单例模式的思考
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-06-29T20:56:36+08:00" content="2016-06-29">
              2016-06-29
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/设计模式/" itemprop="url" rel="index">
                    <span itemprop="name">设计模式</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/06/29/关于单例模式的思考/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/06/29/关于单例模式的思考/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>一直以来呢，对于设计模式感觉就是非常神奇的一个东西。从网上开始搜索一些关于设计模式的教程来学习，不过说真的，仅仅是自己通过网络的资料来学习是非常蛋疼的一件事。因为，没有人指导，感觉就是知其然，不知其所以然，就例如接下来要写的单例模式的猜想。那么，今天要解决什么问题呢？有如下三点：</p>
<blockquote>
<p>1.由于单例模式在内存中的生命周期是当第一次使用的时候开始创建，直到application应用销毁时，才从内存中移除。那么问题在于，单例对象在内存中创建之后，所占的内存大小是多少呢？<br>2.在单例方法中，使用多线程，对单例中属性的影响？<br>3.在那些条件下使用单例、实例及类方法？</p>
</blockquote>
<h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><p>简单说一下单例模式吧（万年不变的梗，百度一堆一样的），算了还是不要讲单例模式了，直接放几个对单例模式讲解不错的博客：</p>
<blockquote>
<p> <a href="http://www.jianshu.com/p/4130096cee03" target="_blank" rel="external">华山论剑之浅谈iOS单例对象</a><br> <a href="https://segmentfault.com/a/1190000003941840" target="_blank" rel="external">iOS中单例模式</a><br> <a href="http://shaynechow.github.io/iOS-Singleton/" target="_blank" rel="external">iOS单例模式</a><br> <a href="http://www.jianshu.com/p/7486ebfcd93b" target="_blank" rel="external">iOS之单例模式初探</a></p>
</blockquote>
<h3 id="单例模式猜想求证"><a href="#单例模式猜想求证" class="headerlink" title="单例模式猜想求证"></a>单例模式猜想求证</h3><p>上面的博客，大体上能讲清楚单例模式，以及单例模式的创建等问题。那么，回到文章的开始，我们提到的几个问题。</p>
<p>看个例子，主要是解决这三个问题的简单例子</p>
<blockquote>
<p> 开发环境: Xcode 7.3<br> 开发语言: Swift 2.2, Objective-C</p>
</blockquote>
<p>示例代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">// SYObject.h</span><br><span class="line">@interface SYObject : NSObject</span><br><span class="line"></span><br><span class="line">+ (SYObject *)shareInstance;</span><br><span class="line">- (size_t)calculateInstanceSize;</span><br><span class="line">- (size_t)calculateInstanceSize2;</span><br><span class="line">- (void)getInstanceIvar;</span><br><span class="line"></span><br><span class="line">@property (nonatomic, assign) long longValue;</span><br><span class="line">@property (nonatomic, assign) BOOL isFailure;</span><br><span class="line">////@property (nonatomic, assign) int value;</span><br><span class="line">////@property (nonatomic, assign) short shortValue;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">// SYObject.m</span><br><span class="line">#import &quot;SYObject.h&quot;</span><br><span class="line">#import &lt;malloc/malloc.h&gt;</span><br><span class="line">#import &lt;objc/runtime.h&gt;</span><br><span class="line"></span><br><span class="line">@implementation SYObject</span><br><span class="line"></span><br><span class="line">+ (SYObject *)shareInstance &#123;</span><br><span class="line">    static SYObject *instance;</span><br><span class="line">    static dispatch_once_t token;</span><br><span class="line">    </span><br><span class="line">    dispatch_once(&amp;token, ^&#123;</span><br><span class="line">        instance = [[self alloc] init];</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    return instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 计算实例大小</span><br><span class="line">- (size_t)calculateInstanceSize &#123;</span><br><span class="line">    size_t size = malloc_size((__bridge const void *)([SYObject shareInstance]));</span><br><span class="line">    </span><br><span class="line">    return size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 计算实例大小</span><br><span class="line">- (size_t)calculateInstanceSize2 &#123;</span><br><span class="line">    size_t size = size = class_getInstanceSize([SYObject class]);</span><br><span class="line">    </span><br><span class="line">    return size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 获取ivars</span><br><span class="line">- (void)getInstanceIvar &#123;</span><br><span class="line">    unsigned int count = 0;</span><br><span class="line">    Class cls = [SYObject class];</span><br><span class="line">    </span><br><span class="line">    Ivar *ivars = class_copyIvarList(cls, &amp;count);</span><br><span class="line">    </span><br><span class="line">    for (int i = 0; i &lt; count; i++) &#123;</span><br><span class="line">        Ivar *ivar = &amp;ivars[i];</span><br><span class="line">        </span><br><span class="line">        NSLog(@&quot;instance variable&apos;s name: %s at index: %d&quot;, ivar_getName(*ivar), i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 调用</span><br><span class="line">let instance = SYObject.shareInstance()</span><br><span class="line">var count = instance.calculateInstanceSize()</span><br><span class="line">print(count)</span><br><span class="line"></span><br><span class="line">count = instance.calculateInstanceSize2()</span><br><span class="line">instance.getInstanceIvar()</span><br><span class="line">print(count)</span><br><span class="line"></span><br><span class="line">Sample Output:</span><br><span class="line">molloc instance size: 32</span><br><span class="line">get instance size: 24</span><br><span class="line">2016-06-30 00:47:27.591 SYMultipleThread[78991:1216822] instance variable&apos;s name: _isFailure at index: 0</span><br><span class="line">2016-06-30 00:47:27.591 SYMultipleThread[78991:1216822] instance variable&apos;s name: _isSuccess at index: 1</span><br></pre></td></tr></table></figure></p>
<p>首先解决第一个问题：单例模式自创建之后，在内存中所占的大小是多少？从上面的例子中，我们容易看出结果，通过我们添加修改属性和私有属性等参数，然后就可以得到单例在内存中最终的结果。</p>
<p>从上面，我们还发现另外两个问题：1.为何两次方法调用的结果不一样？2.计算的结果不是各个类型字节大小之和嘛？<br>第1个问题，在于iOS分配内存时，小于16字节的内存，会直接分配16字节，是在一定程度上提高了存储效率。所以，第一个方法是iOS分配内存的大小，第二个方法则是实际对象所占的内存空间大小。<br>第2个问题，为何不一样？<strong><a href="http://www.cnblogs.com/clover-toeic/p/3853132.html" target="_blank" rel="external">字节对齐</a></strong>，至于什么是字节对齐，就不再展开了。但发现一个问题，就是说iOS会根据我们定义的属性大小自己去分配最小的内存空间（如果没有实验错误的话，C语言中的结构体就不会，所以C做内存优化的时候，可以针对结构体中的变量位置做优化）。</p>
<p>第二个问题的示例代码：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SYThreadModel</span>: <span class="title">NSObject</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> a = <span class="string">""</span></span><br><span class="line">    <span class="keyword">var</span> b = <span class="string">""</span></span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">func</span> <span class="title">shareInstance</span>() -&gt; <span class="title">SYThreadModel</span> </span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Static</span> </span>&#123;</span><br><span class="line">            <span class="keyword">static</span> <span class="keyword">var</span> token: dispatch_once_t = <span class="number">0</span></span><br><span class="line">            <span class="keyword">static</span> <span class="keyword">var</span> instance: <span class="type">SYThreadModel</span>? = <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        dispatch_once(&amp;<span class="type">Static</span>.token) &#123; </span><br><span class="line">            <span class="type">Static</span>.instance = <span class="type">SYThreadModel</span>()</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="type">Static</span>.instance!</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">setValue</span><span class="params">(str: String, ch: String)</span></span> &#123;</span><br><span class="line">        <span class="keyword">let</span> queue = dispatch_get_global_queue(<span class="type">DISPATCH_QUEUE_PRIORITY_DEFAULT</span>, <span class="number">0</span>)</span><br><span class="line">        dispatch_async(queue) &#123; </span><br><span class="line">            <span class="type">SYThreadModel</span>.shareInstance().a = str</span><br><span class="line">            <span class="type">NSThread</span>.sleepForTimeInterval(<span class="number">2</span>)</span><br><span class="line">            <span class="type">SYThreadModel</span>.shareInstance().b = ch</span><br><span class="line">            </span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"<span class="subst">\(SYThreadModel.shareInstance()</span>.a) == <span class="subst">\(SYThreadModel.shareInstance()</span>.b)"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line"><span class="keyword">let</span> instance = <span class="type">SYThreadModel</span>.shareInstance()</span><br><span class="line">instance.setValue(<span class="string">"a"</span>, ch: <span class="string">"b"</span>)</span><br><span class="line">instance.setValue(<span class="string">"c"</span>, ch: <span class="string">"d"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Sample Output</span></span><br><span class="line"><span class="built_in">c</span> == b</span><br><span class="line"><span class="built_in">c</span> == b</span><br></pre></td></tr></table></figure></p>
<p>如上面代码，我们可以看到，这并不是我们想要的结果。那么，问题在于为何会出现这样的问题呢？这就归咎到dispatch_async()，由于在执行过程中，dispatch_async是并行执行，因此谁都有可能改变a或b的值。这也就使得在多线程使用单例会让数据变的很不安全。</p>
<p>第三个问题：</p>
<blockquote>
<p> 单例：使用单例仅仅是保证该类在整个生命周期只会存在一块内存空间，在一定程度上降低了内存空间的开销；<br> 实例：实例是保证数据的隔离，互相不冲突，通常情况下，我们都会选择使用实例对象；<br> 类方法：也称静态方法，它的生命周期，只存在于调用该方法开始，直到该方法执行结束，这是类方法里面开辟的内存空间就会被销毁。</p>
</blockquote>
<p>通过，对三种方法的简单描述，然后自己思考，在具体的项目中应该如何去使用。</p>
<h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>最后，总结一下：单例模式在一定程度上，控制实例个数，节省系统资源；但同样也会使得系统数据变的冗余，（例如：某个类我们只需要使用一次，之后就再也不使用了，如果使用单例，它的生命周期和系统的生命周期是一样的，释放不掉，由此增加了数据的冗余）；尽量不在使用多线程去修改单例属性，否则就像第二个问题一样，使得数据并不安全。因此，在最后的最后，在写代码的过程中，使用好单例模式，切勿滥用，否则出现的后果就非常麻烦。</p>
<h3 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h3><p><a href="http://objccn.io/issue-13-2/" target="_blank" rel="external">避免滥用单例</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/06/29/简历-杨森-iOS开发工程师/" itemprop="url">
                  简历.杨森.iOS开发工程师
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-06-29T13:25:18+08:00" content="2016-06-29">
              2016-06-29
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/简历/" itemprop="url" rel="index">
                    <span itemprop="name">简历</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/06/29/简历-杨森-iOS开发工程师/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/06/29/简历-杨森-iOS开发工程师/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="基本资料"><a href="#基本资料" class="headerlink" title="基本资料"></a>基本资料</h3><blockquote>
<p> 姓   名：杨森<br> 联系电话：13726213088<br> 邮   箱：735003861@qq.com, seninchina@gmail.com<br> 博   客：blog.ysenin.com<br> 应聘职位：iOS开发工程师<br> 工作经验：1年工作、半年实习</p>
</blockquote>
<h3 id="教育背景"><a href="#教育背景" class="headerlink" title="教育背景"></a>教育背景</h3><blockquote>
<p> 毕业院校：北京理工大学珠海学院<br> 专   业：软件工程</p>
</blockquote>
<h3 id="荣誉及获奖情况"><a href="#荣誉及获奖情况" class="headerlink" title="荣誉及获奖情况"></a>荣誉及获奖情况</h3><blockquote>
<p> 程序基础设计协会负责人以及协会培训主讲人<br> 2013广东省ACM-ICPC优胜奖<br> 多次校内算法比赛获奖</p>
</blockquote>
<h3 id="技能"><a href="#技能" class="headerlink" title="技能"></a>技能</h3><blockquote>
<p> 熟练掌握Swift开发语言<br> 熟练代码实现UI编写<br> 熟练掌握MVC架构<br> 基本掌握Autolayout、Masony、Xib布局<br> 基本掌握Objective-C开发语言<br> 基本掌握AVFoundation、UIKit、Foundation等系统框架<br> 基本掌握AFNetworking、FMDB、MBProgressHUD等第三方框架<br> 了解内存管理、block、GCD等多线程技术的使用<br> 初步了解Objective-C的runtime机制、MVVM架构、ReactiveCocoa响应式编程<br> 使用sqlite做数据持久化、Swift与Objective-C混编、Swift语言更新的经历等</p>
</blockquote>
<h3 id="项目经验"><a href="#项目经验" class="headerlink" title="项目经验"></a>项目经验</h3><blockquote>
<p> <strong>珠海轼域网络科技  Mieah邮件客户端 iOS端 Swift2.2（2015.10 - 至今）</strong><br> 简述：<br>      获取Gmail API，获取邮件数据并解析，通过联系人，实现群组功能。用户可以使用客户端发送个人邮件、多人邮件以及群组邮件等功能。</p>
<p> 工作内容：<br>      1.接入Gmail API，解析邮件数据，获取用户和联系人的数据，发送邮件及附件；<br>      2.Mieah项目的UI以及逻辑实现（对话、广告邮件、联系人、设定）；<br>      3.创建群组、分析多人邮件、添加联系人（输入email、手机联系人）等功能实现；<br>      4.通过AFNetworking框架实现客户端与服务器的数据交互；<br>      5.通过sqlite和NSUserDefault实现数据持久化处理；<br>      6.通过AVFoundation系统框架实现音频录制与播放、视频录制裁剪与播放、二维码扫描与解析；<br>      7.读写沙盒数据以及系统相册数据等；<br>      8.网络请求、内存使用调优。</p>
<p> 难点：<br>      邮件内容截取、附件数据下载及展示、群组功能数据与后台的交互等。</p>
<p> <strong>珠海轼域网络科技  skillTemp iOS端 Swift2.0（2015.8 - 2015.10）</strong><br> 简述：<br>      一款类似于italk的技能交易平台，用户将自己拥有的专业技能（洗剪吹，教育技能等）放到平台供需求用户浏览，也可以寻求自己需要的技能，并与该对象达成沟通交易。目前在香港App Store上架。</p>
<p> 工作内容：<br>      1.Facebook数据、分享、点赞；<br>      2.登陆密码加密形式与后台交互；<br>      3.用户协议及隐私的UI和逻辑处理；<br>      4.修改第三方图片浏览器，在图片放大时，出现缩放错误Bug修复；<br>      5.个人资料的显示UI以及逻辑修改；<br>      6.用户对话界面的语音发送、UI和逻辑编写；<br>      7.用户联系人的有序逻辑显示；<br>      8.简单的Google Map和iPhone内置地图的切换显示标注等逻辑；<br>      9.Swift升级带来的问题修复。</p>
<p> 难点：<br>      Swift语言升级时修改API和修改skillTemp的逻辑Bug。</p>
</blockquote>
<h3 id="个人项目"><a href="#个人项目" class="headerlink" title="个人项目"></a>个人项目</h3><blockquote>
<p> <strong>C语言教学辅助系统 iOS端 Objective-C(学校老师带领的项目)</strong><br> 简述：结合教学大纲，制定不同练习模式的教学辅助的应用。<br> 内容：制定练习模式，完成编码实现。<br> 难点：Objective-C语言学习</p>
</blockquote>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><blockquote>
<p> 喜欢思考，喜欢与人交谈<br> 爱看美剧<br> 在杭电ACM刷题（大学），leetcode刷题（付费的太贵，只能看）</p>
</blockquote>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.png"
               alt="ySenIn" />
          <p class="site-author-name" itemprop="name">ySenIn</p>
          <p class="site-description motion-element" itemprop="description">一个孤独的人，一个不想孤独的人</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">14</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">9</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">19</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
  <span id="busuanzi_container_site_pv">pv: <span id="busuanzi_value_site_pv"></span></span>
  <span id="busuanzi_container_site_uv">uv: <span id="busuanzi_value_site_uv"></span></span>
  <span class="author" itemprop="copyrightHolder">ySenIn</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"ysenin"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
  





  
  
  

  

  

</body>
</html>
