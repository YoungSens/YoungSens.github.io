<!doctype html>



  


<html class="theme-next muse use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />





  <link rel="alternate" href="/atom.xml" title="ySenIn's Blog" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta name="description" content="一个孤独的人，一个不想孤独的人">
<meta property="og:type" content="website">
<meta property="og:title" content="ySenIn's Blog">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="ySenIn's Blog">
<meta property="og:description" content="一个孤独的人，一个不想孤独的人">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="ySenIn's Blog">
<meta name="twitter:description" content="一个孤独的人，一个不想孤独的人">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>

  <title> ySenIn's Blog </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">ySenIn's Blog</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">ySen</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-guestbook">
          <a href="/guestbook" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            留言
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/06/25/多线程系列之GCD/" itemprop="url">
                  多线程系列之GCD之一
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-06-25T16:45:34+08:00" content="2016-06-25">
              2016-06-25
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/多线程/" itemprop="url" rel="index">
                    <span itemprop="name">多线程</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/06/25/多线程系列之GCD/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/06/25/多线程系列之GCD/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>网上关于多线程的文章已经烂大街了，问题是为啥我还要继续写呢？没有为啥，单纯想写。看到有些文章空泛的描述出使用的什么方法来生成多线程，然后就扔一堆代码，这种做法真是令人作呕，至少我是这么觉得的。好吧，调侃的差不多了，也来写写自己对于多线程的理解，那么这一片会首先介绍GCD。文章主要参考[Objective-C高级编程、iOS与OS X多线程和内存指南]，一本很不错的书。算了还是不要说参考了，摘抄。</p>
<blockquote>
<p>示例代码语言：Swift 2.2<br>Xcode版本: Xcode 7.3</p>
</blockquote>
<p>那么首先说，什么是GCD呢？按照苹果的官方解释说：GCD(Grand Central Dispatch)是异步执行技术的技术之一。一般将应用程序中技术的线程管理用的代码在系统中实现。开发者只需要定义想执行的任务追加到适当的Dispatch Queue中，GCD生成必要的线程并计划执行任务。由于线程管理是作为系统的一部分来实现的，因此可统一管理，也可执行任务，这样就比之前的线程更有效率（摘自上面提到的参考书，参考书又参考值苹果官方文档，现在沦为文字的搬运工了，呵呵哒）。<br>简单的来讲，就是说我们GCD的API，然后将我们需要执行的处理写在block中，然后把block追加到GCD的队列就可以了，GCD会自己去规划并生成线程进行处理。</p>
<h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p>按照wikipedia中的描述是：线程是操作系统能够进行运算调度的最小单位，它被包含在进程中……线程分为两种，同步与非同步（异步）。同步是在本线程中执行，异步则是开辟新的线程执行。在项目中，适当的使用两者会让整个项目的性能得到很大的提升。虽然在使用多线程时，会遇到很多问题，学会处理多线程带来的问题，及时避免就不会出现太大的问题。</p>
<h4 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h4><p>针对于同步线程来讲，在添加任务到同步线程队列中，只有等前一个任务完成之后，后一个任务才能继续执行。大概意思和队列是一样的，先进先出的原则，正如一条单行线。代码如下：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">"同步线程执行开始"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> queue = dispatch_queue_create(<span class="string">"com.ysenin.symultiplethread"</span>, <span class="literal">nil</span>)</span><br><span class="line">dispatch_sync(queue) &#123; </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"同步线程执行中"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"同步线程执行完毕"</span>)</span><br></pre></td></tr></table></figure></p>
<p>上面这段代码呢，执行结果为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">同步线程执行开始</span><br><span class="line">同步线程执行中</span><br><span class="line">同步线程执行完毕</span><br></pre></td></tr></table></figure></p>
<p><strong>注意</strong>此时需要注意很重要的一点，真的很重要的一点。如果把上面的queue换成dispatch_get_main_queue()呢？这个又会怎样呢？结果只会输出：“同步线程执行开始”。这是为什么呢？如下：</p>
<blockquote>
<p><strong>死锁</strong><br>在调用dispatch_sync(queue)时，需要将线程阻塞，此时是主线程；<br>同步派发sync导致block需要在主线程中执行结束后才会返回；<br>而此时主线程被阻塞，两者相互等待，线程出现死锁。</p>
</blockquote>
<p>同样，Serial Dispatch Queue中，也会出现类似的情况，代码如下：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">"线程执行开始"</span>)</span><br><span class="line">queue = dispatch_queue_create(<span class="string">"com.ysenin.symultiplethread"</span>, <span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..&lt;<span class="number">1000</span> &#123;</span><br><span class="line">    dispatch_async(queue, &#123; </span><br><span class="line">        dispatch_sync(queue, &#123; </span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"线程执行中: <span class="subst">\(i)</span>"</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"线程执行完毕"</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>代码执行的结果为:”线程执行开始”,当然此时代码页面不会阻塞主线程，而仅仅是queue中的派发的线程会阻塞。至于什么事Serial Dispatch Queue，在接下来的部分会讲到。所以，如果在主线程派发队列或者Serial Dispatch Queue中就需要避免上面出现的问题，否则代码写完半天，不出结果，那就比较恶心了。</p>
<h4 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h4><p>上面简单的讲了同步，接下来讲讲异步。异步在我们项目中可是经常遇到的问题，譬如网络数据加载，动画的长时间绘制和大文件处理等。由于我们现在所用到的设备大部分已经不是单核设备，都已经升级为多核，那么对于多核来讲，意味着线程变多，处理变快。随着线程变的多，也就出现了不同的问题。在使用多线程过程中，容易出现一下问题：</p>
<blockquote>
<p>1.数据竞争（两个或者多个线程，更新同一条数据）<br>2.死锁（两个线程相互指向对方）<br>3.大量线程导师消耗大量内存（大量开辟线程）</p>
</blockquote>
<p>当然，解决上述问题的方法会很多，虽然有点难，比起出现的概率和性能的提升，这点难点都不足以阻碍使用GCD。</p>
<p>异步的源代码如下所示：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dispatch_async(queue, &#123; </span><br><span class="line">    <span class="comment">// 想要执行的任务</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>异步执行处理包涵两种队列: Serial Dispatch Queue、Concurrent Dispatch Queue。<br>| Dispatch Queue的种类       | 说明                 |<br>|—————————|———————|<br>| Serial Dispatch Queue     | 等待现在执行中处理结束  |<br>| Concurrent Dispatch Queue | 不等待现在执行中处理结束 |</p>
<p>什么意思呢？举个例子，我们去银行办理业务的时候，通常都会拿号，针对不同的业务，我们可以拿不同形式的号，譬如VIP业务和普通的业务。由于VIP业务不是人人都需要，通常只保留一个通道，相反，普通业务办理的人数会很多，那就需要很多通道。对于办理VIP业务的人来讲，只有等号数在自己前面的人办理完毕后，自己才能去办理自己的业务，这就是我们所说的Serial Dispatch Queue。而办理普通业务的人呢？只要前面通道空闲了，后面的人就可以有序的去办理自己的业务，Concurrent Dispatch Queue也就对应这种场景了。</p>
<h5 id="dispatch-queue-create创建"><a href="#dispatch-queue-create创建" class="headerlink" title="dispatch_queue_create创建"></a>dispatch_queue_create创建</h5><p>上面讲的两种队列创建，可以利用dispatch_queue_create来创建：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Serial Dispatch Queue</span></span><br><span class="line"><span class="keyword">let</span> queue = dispatch_queue_create(<span class="string">"com.ysenin.multiplethread"</span>, <span class="type">DISPATCH_QUEUE_SERIAL</span>)</span><br><span class="line"><span class="keyword">let</span> queue = dispatch_queue_create(<span class="string">"com.ysenin.multiplethread"</span>, <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Concurrent Dispatch Queue</span></span><br><span class="line"><span class="keyword">let</span> queue = dispatch_queue_create(<span class="string">"com.ysenin.multiplethread"</span>, <span class="type">DISPATCH_QUEUE_CONCURRENT</span>)</span><br></pre></td></tr></table></figure></p>
<p>通过上面的代码我们可以看到，dispatch_queue_create含有两个参数：第一个是队列名称，第二个是类型。对于队列名，苹果官方的描述如下：</p>
<blockquote>
<p>A string label to attach to the queue to uniquely identify it in debugging tools such as Instruments…</p>
</blockquote>
<p>意思是说，这个名字仅仅是在你调试的时候知道是哪个线程而已。那么不同对象产生的相同名字的队列，它就是两个区分开的队列。针对这个问题，也是让我思考了很久，然后在<a href="http://stackoverflow.com/questions/19421283/do-2-objects-creating-serial-queues-with-the-same-name-share-the-same-queue" target="_blank" rel="external">stackoverflow</a>中找到答案了。</p>
<p>对于Serial Dispatch Queue，我们看到有两种dispatch_queue_create创建方法，第二个参数可以默认为nil，也可以添加DISPATCH_QUEUE_SERIAL来标识。对于Serial Dispatch Queue，我们可以生成多个，多个队列将并行执行。什么意思呢，还是拿银行的VIP业务例子来说明吧。在同一个地区，有同一个银行的不同的分行，每个分行都有VIP通道，这些通道互不影响，并行处理自己的业务。问题在于，如果一个地区如果有成千上万个分行，但事实上只有10个分行有人办理VIP业务，其他银行也就相当于浪费了。这就是前面提到的大量的生成线程，消耗大量的内存，引起大量的上下文切换，造成不必要浪费。因为，在实际编程中，我们需要避免这类似的情况发生。</p>
<p>那么使用Serial Dispatch Queue也不是没有好处，因为在多线程更新数据的情况下，我们可能遇到多个线程更新到同一个数据。那么Serial Dispatch Queue就很好的避免了这个情况。也不是说完全避免，只是在绝大部分情况下，出现数据竞争的机率变小了。</p>
<blockquote>
<p><strong>说明</strong><br>在iOS 6.0和OS X10.8的版本，已经引入ARC，因此不需要自己去管理内存。</p>
</blockquote>
<p>Serial Dispatch Queue样例代码:<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> queue = dispatch_queue_create(<span class="string">"com.ysenin.multiplethread"</span>, <span class="type">DISPATCH_QUEUE_SERIAL</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..&lt;<span class="number">1000</span> &#123;</span><br><span class="line">    dispatch_async(queue, &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"block: <span class="subst">\(i)</span>"</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Sample Output</span></span><br><span class="line">block: <span class="number">0</span></span><br><span class="line">block: <span class="number">1</span></span><br><span class="line">block: <span class="number">2</span></span><br><span class="line">block: <span class="number">3</span></span><br><span class="line">block: <span class="number">4</span></span><br><span class="line">block: <span class="number">5</span></span><br><span class="line">block: <span class="number">6</span></span><br><span class="line">block: <span class="number">7</span></span><br><span class="line">block: <span class="number">8</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<p>Concurrent Dispatch Queue样例代码:<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> queue = dispatch_queue_create(<span class="string">"com.ysenin.multiplethread"</span>, <span class="type">DISPATCH_QUEUE_CONCURRENT</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..&lt;<span class="number">1000</span> &#123;</span><br><span class="line">    dispatch_async(queue, &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"block: <span class="subst">\(i)</span>"</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Sample Output</span></span><br><span class="line">block: <span class="number">2</span></span><br><span class="line">block: <span class="number">3</span></span><br><span class="line">block: <span class="number">1</span></span><br><span class="line">block: <span class="number">4</span></span><br><span class="line">block: <span class="number">0</span></span><br><span class="line">block: <span class="number">6</span></span><br><span class="line">block: <span class="number">5</span></span><br><span class="line">block: <span class="number">7</span></span><br><span class="line">block: <span class="number">8</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<p>针对于具有相同名称的Serial Dispatch Queue生成的多个queue源码示例如下：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> queue = dispatch_queue_create(<span class="string">"com.ysenin.multiplethread"</span>, <span class="type">DISPATCH_QUEUE_SERIAL</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..&lt;<span class="number">10</span> &#123;</span><br><span class="line">    dispatch_async(queue, &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"block: <span class="subst">\(i)</span>"</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">queue = dispatch_queue_create(<span class="string">"com.ysenin.multiplethread"</span>, <span class="type">DISPATCH_QUEUE_SERIAL</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..&lt;<span class="number">10</span> &#123;</span><br><span class="line">    dispatch_async(queue, &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"block123: <span class="subst">\(i)</span>"</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Sample Output</span></span><br><span class="line">block: <span class="number">0</span></span><br><span class="line">block123: <span class="number">0</span></span><br><span class="line">block: <span class="number">1</span></span><br><span class="line">block123: <span class="number">1</span></span><br><span class="line">block: <span class="number">2</span></span><br><span class="line">block123: <span class="number">2</span></span><br><span class="line">block: <span class="number">3</span></span><br><span class="line">block123: <span class="number">3</span></span><br><span class="line">block: <span class="number">4</span></span><br><span class="line">block123: <span class="number">4</span></span><br><span class="line">block: <span class="number">5</span></span><br><span class="line">block123: <span class="number">5</span></span><br><span class="line">block: <span class="number">6</span></span><br><span class="line">block123: <span class="number">6</span></span><br><span class="line">block: <span class="number">7</span></span><br><span class="line">block123: <span class="number">7</span></span><br><span class="line">block: <span class="number">8</span></span><br><span class="line">block123: <span class="number">8</span></span><br><span class="line">block: <span class="number">9</span></span><br><span class="line">block123: <span class="number">9</span></span><br></pre></td></tr></table></figure></p>
<h5 id="Global-Dispatch-Queue创建"><a href="#Global-Dispatch-Queue创建" class="headerlink" title="Global Dispatch Queue创建"></a>Global Dispatch Queue创建</h5><p>这个是获取系统标准提供的Dispatch Queue。也即是说，我们可以不需要像上一节提供的那样自己创建Dispatch Queue,系统自己会给我们提供几个Dispatch Queue使用，分别是：Main Dispatch Queue和Global Dispatch Queue。</p>
<p><strong>Main Dispatch Queue顾名思义就是主线程中执行的Dispatch Queue，因为主线程只有1个，所以Main Dispatch Queue也就是Serial Dispatch Queue。另外一个Global Dispatch Queue是所有应用程序都能使用的Concurrent Dispatch Queue。</strong></p>
<p>Global Dispatch Queue有4个优先级，分别是High Priority(最高优先级)、 Default Priority(默认优先级)、 Low Priority(低优先级)、 Background Priority(后台优先级)。通过XNU内核管理用于Global Dispatch Queue的线程，将各自使用的Global Dispatch Queue的执行优先级作为线程执行的优先级。在Global Dispatch Queue追加处理时，应该选择与处理内容对应的执行优先级的Global Dispatch Queue。</p>
<blockquote>
<p>注意：XUN内核用语Global Dispatch Queue的线程并不能保证实时性，因此优先级之时大致的判断。</p>
</blockquote>
<p>关于Global Dispatch Queue获取和使用的源代码如下：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> mainQueue = dispatch_get_main_queue() <span class="comment">// Main Dispatch Queue的获取方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line">  * Global Dispatch Queue获取</span><br><span class="line">  * DISPATCH_QUEUE_PRIORITY_HIGH       -- 最高优先级</span><br><span class="line">  * DISPATCH_QUEUE_PRIORITY_DEFAULT    -- 默认优先级</span><br><span class="line">  * DISPATCH_QUEUE_PRIORITY_LOW        -- 低优先级</span><br><span class="line">  * DISPATCH_QUEUE_PRIORITY_BACKGROUND -- 后台优先级</span><br><span class="line">  */</span></span><br><span class="line"><span class="comment">// 其他按照上面给出来的名称，改变参数就可以了</span></span><br><span class="line"><span class="keyword">let</span> queue = dispatch_get_global_queue(<span class="type">DISPATCH_QUEUE_PRIORITY_HIGH</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">dispatch_async(queue, ^&#123;</span><br><span class="line">    <span class="comment">// 可执行的处理</span></span><br><span class="line"></span><br><span class="line">    dispatch_async(mainQueue, ^&#123;</span><br><span class="line">        <span class="comment">// 主线程中的处理</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<h5 id="dispatch-set-target-queue"><a href="#dispatch-set-target-queue" class="headerlink" title="dispatch_set_target_queue"></a>dispatch_set_target_queue</h5><p>关于这个函数，有两种功能：1.变更Dispatch Queue的执行优先级；2.作为Dispatch Queue的执行阶层。</p>
<p>第一个功能意思是什么呢？我们看下dispatch_set_target_queue(sourceQueue, goalQueue)。第一个参数为源Dispatch Queue，第二个参数为目标Dispatch Queue。那么结果就是将源Dispatch Queue的优先级设置为目标Dispatch Queue的优先级。</p>
<blockquote>
<p>注: dispatch_queue_create创建的Dispatch Queue，不管是Serial Dispatch Queue还是Concurrent Dispatch Queue，默认优先级都是Global Dispatch Queue中的DISPATCH_QUEUE_PRIORITY_DEFAULT相同的。</p>
</blockquote>
<p>至于第二个功能嘛，很简单，可以理解为，合并几个通过dispatch_queue_create创建的Dispatch Queue为1个Serial Dispatch Queue。当然啦，也可以作为Concurrent Dispatch Queue。但是那不就是合并之前Dispatch Queue嘛。</p>
<blockquote>
<p>注：只能合并dispatch_queue_create创建的Dispatch Queue，不能合并通过Global Dispatch Queue创建，至于为什么嘛，啥时候找找原理，测试是不可以的。</p>
</blockquote>
<p>第二个功能的示例代码如下：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">testTargetQueue</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">let</span> targetQueue = dispatch_queue_create(<span class="string">"target"</span>, <span class="type">DISPATCH_QUEUE_SERIAL</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> queue1 = dispatch_queue_create(<span class="string">"queue1"</span>, <span class="type">DISPATCH_QUEUE_SERIAL</span>)</span><br><span class="line">    <span class="keyword">let</span> queue2 = dispatch_queue_create(<span class="string">"queue2"</span>, <span class="type">DISPATCH_QUEUE_CONCURRENT</span>)</span><br><span class="line">    <span class="keyword">let</span> queue3 = dispatch_get_global_queue(<span class="type">DISPATCH_QUEUE_PRIORITY_DEFAULT</span>, <span class="number">0</span>)</span><br><span class="line">    </span><br><span class="line">    dispatch_set_target_queue(queue1, targetQueue)</span><br><span class="line">    dispatch_set_target_queue(queue2, targetQueue)</span><br><span class="line">    dispatch_set_target_queue(queue3, targetQueue)</span><br><span class="line">    </span><br><span class="line">    dispatch_async(queue1) &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"start queue1"</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="type">NSThread</span>.sleepForTimeInterval(<span class="number">2</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"end queue1"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    dispatch_async(queue2) &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"start queue2"</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="type">NSThread</span>.sleepForTimeInterval(<span class="number">2</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"end queue2"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    dispatch_async(queue3) &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"start queue3"</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="type">NSThread</span>.sleepForTimeInterval(<span class="number">2</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"end queue3"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Sample Output:</span></span><br><span class="line">start queue3</span><br><span class="line">start queue1</span><br><span class="line">end queue3</span><br><span class="line">end queue1</span><br><span class="line">start queue2</span><br><span class="line">end queue2</span><br></pre></td></tr></table></figure></p>
<p>通过上面的样例输出，可以看到Global Dispatch Queue是不能通过dispatch_set_target_queue改变执行阶级的。</p>
<h5 id="dispatch-after"><a href="#dispatch-after" class="headerlink" title="dispatch_after"></a>dispatch_after</h5><p>简单说一下，就是多长时间之后，执行需要的操作。</p>
<blockquote>
<p>dispatch_after(time, queue, block)<br>time: dispatch_time(DISPATCH_TIME_NOW, Int64(3 * NSEC_PER_SEC))<br>          startTime: 起始时间<br>          endTime: 相对的结束时间<br>queue: 在哪个线程队列中执行<br>block: 执行的操作</p>
<p>注：dispatch_after的time，并不是绝对的时间，实际时间决定于该线程所在的runloop的执行时间，例如，runloop每0.01秒执行一次，那就是最快time，最慢响应时间为time + 0.01。</p>
</blockquote>
<h5 id="Dispatch-Group"><a href="#Dispatch-Group" class="headerlink" title="Dispatch Group"></a>Dispatch Group</h5><p>在追加到Dipatch Queue中的多个处理全部结束后，想执行结束操作。如果只使用Serial Dispatch Queue，这需要前者处理完毕之后，后面的才能有序的处理，在时间效率上会比较低下。在这种情况下，使用Dispatch Group，就可以轻松搞定。<br>示例代码如下：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> group = dispatch_group_create()</span><br><span class="line"><span class="keyword">let</span> queue = dispatch_get_global_queue(<span class="type">DISPATCH_QUEUE_PRIORITY_DEFAULT</span>, <span class="number">0</span>)</span><br><span class="line">        </span><br><span class="line">dispatch_group_async(group, queue) &#123; </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"block 1"</span>)</span><br><span class="line">&#125;</span><br><span class="line">dispatch_group_async(group, queue) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"block 2"</span>)</span><br><span class="line">&#125;</span><br><span class="line">dispatch_group_async(group, queue) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"block 3"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dispatch_group_notify(group, dispatch_get_main_queue()) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"done"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Sample Output</span></span><br><span class="line">block <span class="number">1</span></span><br><span class="line">block <span class="number">3</span></span><br><span class="line">block <span class="number">2</span></span><br><span class="line">done</span><br></pre></td></tr></table></figure></p>
<p>当然，在我们执行的group的过程中，我们是可以等待追加的所有处理完毕，之后再进行下一步处理，也可以在我们规定的时间内，进行下一步操作。那么，这就需要用到dispatch_group_wait(group, DISPATCH_TIME_FOREVER)。第一个参数：上面定义的group；第二个参数：定义的执行时间，DISPATCH_TIME_FOREVER即等待所有执行结束，也可以使用dispatch_time定义的等待时间。具体代码如下：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> time = dispatch_time(<span class="type">DISPATCH_TIME_NOW</span>, <span class="number">0</span>)</span><br><span class="line"><span class="keyword">let</span> result = dispatch_group_wait(group, time)</span><br><span class="line"><span class="keyword">if</span> result == <span class="number">0</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Done"</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Not Finish."</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Sample Output:</span></span><br><span class="line"><span class="type">Not</span> <span class="type">Finish</span>.</span><br></pre></td></tr></table></figure></p>
<h5 id="dispatch-barrier-async"><a href="#dispatch-barrier-async" class="headerlink" title="dispatch_barrier_async"></a>dispatch_barrier_async</h5><p>这是个什么函数呢？还是给个场景吧，数据库读写的时候，发现在我们更新到的时候，需要写入数据。那么，在更新前是不需要什么处理的，但更新后的数据想要读出新数据，这该怎么办呢？</p>
<p>上面的问题，我们可以通过Serial Dispatch Queue处理，Serial Dispatch Queue的特性又是单通道，只能串行执行，效率不高。在这种情况下，GCD给我们提供了更加聪明的方法dispatch_barrier_async。配合Concurrent Dispatch Queue使用dispatch_barrier_async处理，会将更新的数据并行执行，处理完成后做dispatch_barrier_async的追加处理，之后再做余下的并行执行。</p>
<p>也就是说，dispatch_barrier_async类似于坐过山车，前面的人怎么排队都好，只有人齐才会发车。只有过山车停，人才可以下来，然后做各自喜欢的事情。那么dispatch_barrier_async就很好的把控了两者之间的关口，达到数据统一。</p>
<p>dispatch_barrier_async(queue, block)，第一个参数为处理的队列，第二个为执行的处理。示例代码如下：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> queue = dispatch_queue_create(<span class="string">"text"</span>, <span class="type">DISPATCH_QUEUE_CONCURRENT</span>)</span><br><span class="line">        </span><br><span class="line">dispatch_async(queue) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"handler start 1"</span>)</span><br><span class="line">    <span class="type">NSThread</span>.sleepForTimeInterval(<span class="number">2</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"handler end 1"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dispatch_async(queue) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"handler start 2"</span>)</span><br><span class="line">    <span class="type">NSThread</span>.sleepForTimeInterval(<span class="number">2</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"handler end 2"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dispatch_async(queue) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"handler start 3"</span>)</span><br><span class="line">    <span class="type">NSThread</span>.sleepForTimeInterval(<span class="number">2</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"handler end 3"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dispatch_barrier_async(queue) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"barrier handler start"</span>)</span><br><span class="line">    <span class="type">NSThread</span>.sleepForTimeInterval(<span class="number">2</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"barrier handler end"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dispatch_async(queue) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"handler start 4"</span>)</span><br><span class="line">    <span class="type">NSThread</span>.sleepForTimeInterval(<span class="number">2</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"handler end 4"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dispatch_async(queue) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"handler start 5"</span>)</span><br><span class="line">    <span class="type">NSThread</span>.sleepForTimeInterval(<span class="number">2</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"handler end 5"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dispatch_async(queue) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"handler start 6"</span>)</span><br><span class="line">    <span class="type">NSThread</span>.sleepForTimeInterval(<span class="number">2</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"handler end 6"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Sample Output</span></span><br><span class="line">handler start <span class="number">1</span></span><br><span class="line">handler start <span class="number">3</span></span><br><span class="line">handler start <span class="number">2</span></span><br><span class="line">handler end <span class="number">3</span></span><br><span class="line">handler end <span class="number">1</span></span><br><span class="line">handler end <span class="number">2</span></span><br><span class="line">barrier handler start</span><br><span class="line">barrier handler end</span><br><span class="line">handler start <span class="number">4</span></span><br><span class="line">handler start <span class="number">5</span></span><br><span class="line">handler start <span class="number">6</span></span><br><span class="line">handler end <span class="number">5</span></span><br><span class="line">handler end <span class="number">4</span></span><br><span class="line">handler end <span class="number">6</span></span><br></pre></td></tr></table></figure></p>
<p>值得注意一点的就是：我们生成的Dispatch Queue必须是通过dispatch_queue_create生成的Concurrent Dispatch Queu，否则无效，即使Global Dispatch Queue在一定意义上也是Concurrent Dispatch Queu。</p>
<h5 id="dispatch-apply"><a href="#dispatch-apply" class="headerlink" title="dispatch_apply"></a>dispatch_apply</h5><p>dispatch_apple函数时dispatch_sync函数和Dispatch Group的关联API，高函数制定的次数将指定的block追加到Dispatch Queue中，并等待结束。开示例代码吧，这个容易懂：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> queue = dispatch_get_global_queue(<span class="type">DISPATCH_QUEUE_PRIORITY_DEFAULT</span>, <span class="number">0</span>)</span><br><span class="line"><span class="keyword">let</span> array: [<span class="type">Int</span>] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>]</span><br><span class="line"></span><br><span class="line">dispatch_apply(array.<span class="built_in">count</span>, queue) &#123; (index: <span class="type">Int</span>) <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(array[index])</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"done"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Sample Output</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line">done</span><br></pre></td></tr></table></figure></p>
<p>dispatch_apply(count, queue, block(index: Int))，第一个参数为执行几次，第二个参数为执行的队列，第三个参数为执行的第index个block。通过示例代码我们会发现，在dispatch_apply内部的block是异步执行的，但只有执行完count次之后，才会结束。也就是说，dispatch_apply是同步的，但在内部的count次block执行，确实异步的。<br>因此，在实际处理过程中，将dispatch_apply写在异步执行代码块中。</p>
<h5 id="dispatch-suspend-dispatch-resume"><a href="#dispatch-suspend-dispatch-resume" class="headerlink" title="dispatch_suspend/dispatch_resume"></a>dispatch_suspend/dispatch_resume</h5><p>dispatch_suspend(queue): 将queue挂起，即放到阻塞线程中，等待激活。<br>dispatch_resume(queue): 恢复queue，从阻塞状态变为就绪状态，等到执行。</p>
<h5 id="dispatch-once"><a href="#dispatch-once" class="headerlink" title="dispatch_once"></a>dispatch_once</h5><p>dispatch_once保证在应用程序中只执行一次处理，主要解决在多线程环境下，保证安全。常用于单例模式，生成单例对象时使用。<br>示例代码：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">var</span> <span class="title">shareInstance</span>: <span class="title">SYObjectClass</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Static</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">var</span> onceToken: dispatch_once_t = <span class="number">0</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">var</span> instance: <span class="type">SYObjectClass</span>?</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    dispatch_once(&amp;<span class="type">Static</span>.onceToken) &#123; </span><br><span class="line">        <span class="type">Static</span>.instance = <span class="type">SYObjectClass</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="type">Static</span>.instance!</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>花了几天时间，把GCD看了下，以前没怎么仔细花功夫看过，因此这次所花的时间还是值得的，把之前关于GCD比较纳闷的问题解决了一下。GCD是纯C语言的API；处理同步数据的时候非常高效，不需要添加同步锁；使用GCD的dispatch_once也可以保证在多线程中之生成一个对象等。至于和几种方式的区别，会在接下来几篇关于多线程处理方法写完之后做一个总结。不管怎样，只有在项目中在适当的地方，添加合适的多线程处理方式，才能让项目变得更加好。</p>
<h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><p>1.[Objective-C高级编程 iOS与OS X多线程和内存指南]<br>2.[Effective Objective-C 2.0编写高质量iOS和OS X代码的52个有效方法]<br>3.<a href="http://www.infoq.com/cn/articles/os-x-ios-multithread-technology" target="_blank" rel="external">OS X 和 iOS 中的多线程技术</a><br>4.<a href="https://www.zybuluo.com/MicroCai/note/64272" target="_blank" rel="external">Effective Objective-C Notes：GCD 实现同步锁</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/06/22/iOS利用Runtime机制添加额外的属性/" itemprop="url">
                  iOS在分类(Category)中添加并使用属性
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-06-22T21:40:51+08:00" content="2016-06-22">
              2016-06-22
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Runtime/" itemprop="url" rel="index">
                    <span itemprop="name">Runtime</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/06/22/iOS利用Runtime机制添加额外的属性/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/06/22/iOS利用Runtime机制添加额外的属性/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在很多时候，我们想给某些类增加一些属性，用于传值或者用做与其他用途。问题在于，调用系统给定的类，使得我们无法去做更改，必须通过代理、通知之类的方式传递。这类似的做法，让我们变得非常被动，写一堆代码， 只是为了传递一个小参数。</p>
<p>对于此类问题的解决方案呢，是利用Runtime机制，在分类里给某个类增加额外的属性。按理说，分类是允许添加属性的，但不会自动生成getter和setter方法的。可为啥我们还是可以在分类增加属性，并能生成getter和setter方法呢？那么这就说到我们的黑魔法–Runtime的关联引用。</p>
<p>给个场景吧，曾今在项目中遇到过的问题。在UITableViewCell的contentView中添加一个自定义button，button用于头像显示，点击头像显示大图。解决方案有很多种，例如设置button的tag为cell indexPath.row、判断点击区域等。现在我想通过button的属性来确定点击button的值，该怎么做呢？</p>
<p>前面我们说到，可以在分类(Category)添加属性，并通过关联引用来设置属性getter和setter方法。现在我们给button增加一个iamgeName属性，用于显示图片的名称。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@property (nonatomic, copy) NSString *imageName;</span><br></pre></td></tr></table></figure></p>
<p>1.项目介绍，主要是自定义cell中，添加button，点击button打印button的imageName.<br><figure class="highlight plain"><figcaption><span>[lang:.m] [title] [url] [link text]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">ViewController.m</span><br><span class="line">- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath &#123;</span><br><span class="line">    SYTableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:@&quot;cell&quot;]; // 自定义cell</span><br><span class="line">    </span><br><span class="line">    if (cell == nil) &#123;</span><br><span class="line">        cell = [[SYTableViewCell alloc] initWithStyle:UITableViewCellStyleDefault reuseIdentifier:@&quot;cell&quot;];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    [cell setHeaderImage:@&quot;header.jpg&quot;]; // button的图片</span><br><span class="line">    </span><br><span class="line">    return cell;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//  SYTableViewCell.h</span><br><span class="line"></span><br><span class="line">#import &lt;UIKit/UIKit.h&gt;</span><br><span class="line">#import &quot;UIButton+SYAssociteObject.h&quot; // 黑魔法文件</span><br><span class="line"></span><br><span class="line">@interface SYTableViewCell : UITableViewCell</span><br><span class="line"></span><br><span class="line">@property (nonatomic, strong) UIButton *button;</span><br><span class="line"></span><br><span class="line">- (void)setHeaderImage:(NSString *)imageName;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">//  SYTableViewCell.m</span><br><span class="line"></span><br><span class="line">#import &quot;SYTableViewCell.h&quot;</span><br><span class="line"></span><br><span class="line">@implementation SYTableViewCell</span><br><span class="line"></span><br><span class="line">- (id)initWithStyle:(UITableViewCellStyle)style reuseIdentifier:(NSString *)reuseIdentifier &#123;</span><br><span class="line">    self = [super initWithStyle:style reuseIdentifier:reuseIdentifier];</span><br><span class="line">    </span><br><span class="line">    if (self) &#123;</span><br><span class="line">        _button = [UIButton buttonWithType:UIButtonTypeCustom];</span><br><span class="line">        _button.frame = CGRectMake(15, 5, 40, 40);</span><br><span class="line">        _button.layer.cornerRadius = 5;</span><br><span class="line">        _button.layer.masksToBounds = YES;</span><br><span class="line">        _button.backgroundColor = [UIColor redColor];</span><br><span class="line">        [_button addTarget:self action:@selector(buttonAction:) forControlEvents:UIControlEventTouchUpInside];</span><br><span class="line">        _button.imageName = @&quot;gaga&quot;;</span><br><span class="line">        </span><br><span class="line">        [self addSubview:_button];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)setHeaderImage:(NSString *)imageName &#123; // 设置button图片</span><br><span class="line">    _button.imageName = imageName;</span><br><span class="line">    </span><br><span class="line">    [_button setImage:[UIImage imageNamed:imageName] forState:UIControlStateNormal];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)buttonAction:(UIButton *)sender &#123; // 点击button响应事件</span><br><span class="line">    NSLog(@&quot;%@&quot;, sender.imageName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>2.黑魔法文件，方法1，2，3，4只是相同的方法实现，不同的参数而已。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">//  UIButton+SYAssociteObject.h</span><br><span class="line"></span><br><span class="line">#import &lt;UIKit/UIKit.h&gt;</span><br><span class="line"></span><br><span class="line">@interface UIButton (SYAssociteObject)</span><br><span class="line"></span><br><span class="line">@property (nonatomic, copy) NSString *imageName;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">//  UIButton+SYAssociteObject.m</span><br><span class="line"></span><br><span class="line">#import &quot;UIButton+SYAssociteObject.h&quot;</span><br><span class="line">#import &lt;objc/runtime.h&gt; // 很重要</span><br><span class="line"></span><br><span class="line">@implementation UIButton (SYAssociteObject)</span><br><span class="line"></span><br><span class="line">// 方法1，2，3</span><br><span class="line">static void *strKey = &amp;strKey;</span><br><span class="line">static NSString *charKey = @&quot;char&quot;;</span><br><span class="line">static char str;</span><br><span class="line"></span><br><span class="line">- (void)setImageName:(NSString *)imageName &#123;</span><br><span class="line">    objc_setAssociatedObject(self, &amp;strKey, imageName, OBJC_ASSOCIATION_COPY_NONATOMIC);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (NSString *)imageName &#123;</span><br><span class="line">    return objc_getAssociatedObject(self, &amp;strKey);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 方法4</span><br><span class="line">//- (void)setImageName:(NSString *)name &#123;</span><br><span class="line">//    objc_setAssociatedObject(self, @selector(imageName), name, OBJC_ASSOCIATION_COPY_NONATOMIC);</span><br><span class="line">//&#125;</span><br><span class="line">//</span><br><span class="line">//- (NSString *)imageName &#123;</span><br><span class="line">//    return objc_getAssociatedObject(self, @selector(imageName));</span><br><span class="line">//&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p>
<p>getter和setter方法都试利用关联引用，setter中包涵四个属性(源对象，关联key，关联对象，关联策略)。关联对象即我们的目标对象，关联策略即我们平时使用的修饰符，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> typedef OBJC_ENUM(uintptr_t, objc_AssociationPolicy) &#123;</span><br><span class="line">    OBJC_ASSOCIATION_ASSIGN = 0,           //  ==&gt; 指定assign引用关联的对象</span><br><span class="line">    OBJC_ASSOCIATION_RETAIN_NONATOMIC = 1, //  ==&gt; 指定retain非原子属性的关联的对象</span><br><span class="line">    OBJC_ASSOCIATION_COPY_NONATOMIC = 3,   //  ==&gt; 指定copy非原子属性的关联的对象</span><br><span class="line">    OBJC_ASSOCIATION_RETAIN = 01401,       //  ==&gt; 指定retain原子属性的关联的对象</span><br><span class="line">    OBJC_ASSOCIATION_COPY = 01403          //  ==&gt; 指定copy原子属性的关联的对象</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>以上就是给我们不能添加属性的类，增加自定义属性。正如上面提到的场景，当我们点击button的使用，就可以传递我们需要的参数，而不是使用通知等方法来实现此类结果。虽然文件项目增加了，但是用着确实非常舒服。当然，如果你还有其他方法，也欢迎一起探讨。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/06/21/iOS-10权限使用/" itemprop="url">
                  iOS 10权限使用
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-06-21T11:49:28+08:00" content="2016-06-21">
              2016-06-21
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/iOS-10/" itemprop="url" rel="index">
                    <span itemprop="name">iOS 10</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/06/21/iOS-10权限使用/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/06/21/iOS-10权限使用/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>前几天升级iOS 10，想体验一下，bug实在是太多了，改天写篇文章说一下遇到的相关问题好了。现在iOS 10是开发者的预览版，还没有公开测试版，也就是说通过开发者可以获得一个profile链接，然后下载就可以了。至于Xcode8.0嘛，那就直接在<a href="https://developer.apple.com/download/" target="_blank" rel="external">苹果开发者网站</a>下载就没问题了，网速慢的话，度娘也可以。那么先说今天遇到的问题吧，在今天准备真机测试的时候发现崩溃了，就这么崩溃了。泪崩，以前都没有遇到过。是什么问题呢？看一下Console的log吧。</p>
<blockquote>
<p>This app has crashed because it attempted to access privacy-sensitive data without a usage description.  The app’s Info.plist must contain an NSCameraUsageDescription key with a string value explaining to the user how the app uses this data.</p>
</blockquote>
<p>大概意思就是：应用崩溃了，主要原因是访问了没有描述的敏感数据，如果要使用就必须在应用的Info.plist文件中必须添加一个NSCameraUsageDescription的字符串key，来解释应用如何使用这些数据。</p>
<p>当然，如果你要使用其他权限，使用相应的key就可以了，因为权限造成的崩溃的时候，将该key添加到Info.plist文件中即可。value就可以随便定义，中文也可以。常见的key如下：</p>
<blockquote>
<p>相机： NSCameraUsageDescriptio: ncameraDesciption<br>通信录： NSContactsUsageDescription: contactsDesciption<br>麦克风： NSMicrophoneUsageDescription: microphoneDesciption<br>相机： NSPhotoLibraryUsageDescription: photoLibraryDesciption</p>
</blockquote>
<p>Info.plist截图如下：<br><img src="/images/plist.jpg" alt="plist截图"></p>
<p>之后编译运行就可以正常使用，不会出现崩溃显现想了。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/24/MBProgressHUD源码解读/" itemprop="url">
                  MBProgressHUD源码解读
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-24T23:10:24+08:00" content="2016-05-24">
              2016-05-24
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/源码剖析/" itemprop="url" rel="index">
                    <span itemprop="name">源码剖析</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/05/24/MBProgressHUD源码解读/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/05/24/MBProgressHUD源码解读/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p> 源码参见：<a href="https://github.com/jdg/MBProgressHUD" target="_blank" rel="external">https://github.com/jdg/MBProgressHUD</a><br> 版本：0.9.2</p>
<h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>MBProgressHUD是一个HUD窗口的第三方库，用在执行一些后台任务时的，在程序显示一些进度和提示的窗口，其大部分时间都是用于一些网络交互时的进度提示等。相对于上个版本，这个版本添加了消失的动画，也修改了布局方式，采用约束来实现布局等。</p>
<p>本文主要是从最新的源码讲解它的实现讲解。</p>
<h3 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h3><p>MBProgressHUD中定义了一个MBProgressHUDMode枚举类型，它主要是定义HUD显示的模式。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">typedef NS_ENUM(NSInteger, MBProgressHUDMode) &#123;</span><br><span class="line"></span><br><span class="line">     /// 使用UIActivityIndicatorView显示进度，默认值</span><br><span class="line">     MBProgressHUDModeIndeterminate,</span><br><span class="line"></span><br><span class="line">     /// 以前时饼状图，现在内外圈，两个圆环，内圈是一个圆环进度</span><br><span class="line">     MBProgressHUDModeDeterminate,</span><br><span class="line"></span><br><span class="line">     /// 这个直观的来讲就是一个进度条</span><br><span class="line">     MBProgressHUDModeDeterminateHorizontalBar,</span><br><span class="line"></span><br><span class="line">     /// 这是一个一个圆环进度条，和MBProgressHUDModeDeterminate相差不多。细节上的吧。</span><br><span class="line">     MBProgressHUDModeAnnularDeterminate,</span><br><span class="line"></span><br><span class="line">     /// 自定义控件view</span><br><span class="line">     MBProgressHUDModeCustomView,</span><br><span class="line"></span><br><span class="line">     /// 只显示文字</span><br><span class="line">     MBProgressHUDModeText</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>通过设置mode，来显示不同的模式。当然，我们还可以设置title和detailTitle。这些都会在我们的设置中显示，在MBProgressHUD的Demo中可以看到这些不同mode的应用。</p>
<h3 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h3><p>在最新的version中（以前应该也有，没留意以前的代码），MBProgressHUD消失的时候使用了动画，这使得在使用HUD过程中提供了更好的交互体验。只不过动画，只在消失的时候提供了简单的几种类型。事实上显示的时候也是有动画的，由于构造方法没有添加相关值，因此只能使用默认动画显示。如果要修改显示时的动画，有两种方案，1.修改源代码；2.添加构造新的构造方法。相对于第一种，第二种方案的可塑性会更加好，也因此建议自己在源代码中添加自己的构造方法。动画类型如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">typedef NS_ENUM(NSInteger, MBProgressHUDAnimation) &#123;</span><br><span class="line">    /// 不透明动画</span><br><span class="line">    MBProgressHUDAnimationFade,</span><br><span class="line"></span><br><span class="line">    /// 从原比例到0.5倍比例</span><br><span class="line">    MBProgressHUDAnimationZoom,</span><br><span class="line">  </span><br><span class="line">    /// 从原比例到1.5倍比例</span><br><span class="line">    MBProgressHUDAnimationZoomOut,</span><br><span class="line">    </span><br><span class="line">   /// 从原比例到0.5倍比例</span><br><span class="line">   MBProgressHUDAnimationZoomIn</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h3><p>MBProgressHUD分为几种类型，正如mode类型一样，期间的一些view和title是可以自由组合的。通过源码我们可以看到HUD中包含bezelView，titleLabel，detailLabel，button。然后在我们的视图中，通过模式的选择展现出来。</p>
<h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><p>MBProgressHUD提供了一些属性，给予我们更大的操作性，譬如宽限时间，最小显示时间，隐藏时是否从父视图移除等等。具体的如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">// 宽限时间，由于在使用HUD过程中，大部分都是用在网络请求过程中。如果网络请求过程很短，那么使用HUD在加载完毕就消失使得体验不是特别好。因此，可以使用graceTime赋予一个设定值，网络加载短于这个时间将不会显示HUD视图。</span><br><span class="line">@property (assign, nonatomic) NSTimeInterval graceTime;</span><br><span class="line"></span><br><span class="line">// 最短显示时间，默认值为0. 在网络请求很短时，为了提供一个良好的交互体验，设置一个minShowTime，就算网络加载时间少于minShowTime，也至少会显示minShowTime的时间。</span><br><span class="line">@property (assign, nonatomic) NSTimeInterval minShowTime;</span><br><span class="line"></span><br><span class="line">// 是否在隐藏时从父视图上移除，默认为NO</span><br><span class="line">@property (assign, nonatomic) BOOL removeFromSuperViewOnHide;</span><br><span class="line"></span><br><span class="line">// HUD模式，参见模式类型</span><br><span class="line">@property (assign, nonatomic) MBProgressHUDMode mode;</span><br><span class="line"></span><br><span class="line">// 设置labels和indicators的主体颜色，同样还有tintColor。</span><br><span class="line">@property (strong, nonatomic, nullable) UIColor *contentColor UI_APPEARANCE_SELECTOR;</span><br><span class="line"></span><br><span class="line">// 消失时的动画类型，参见动画。</span><br><span class="line">@property (assign, nonatomic) MBProgressHUDAnimation animationType UI_APPEARANCE_SELECTOR;</span><br><span class="line"></span><br><span class="line">// bezel视图相对于父视图的偏移量</span><br><span class="line">@property (assign, nonatomic) CGPoint offset UI_APPEARANCE_SELECTOR;</span><br><span class="line"></span><br><span class="line">// HUD各元素与HUD边缘的距离，默认为20</span><br><span class="line">@property (assign, nonatomic) CGFloat margin UI_APPEARANCE_SELECTOR;</span><br><span class="line"></span><br><span class="line">// HUD bezel的最小大笑，默认为0</span><br><span class="line">@property (assign, nonatomic) CGSize minSize UI_APPEARANCE_SELECTOR;</span><br><span class="line"></span><br><span class="line">// 只读属性，HUD是否是正方形</span><br><span class="line">@property (assign, nonatomic, getter = isSquare) BOOL square UI_APPEARANCE_SELECTOR;</span><br><span class="line"></span><br><span class="line">// 这个不太清楚是干啥的</span><br><span class="line">@property (assign, nonatomic, getter=areDefaultMotionEffectsEnabled) BOOL defaultMotionEffectsEnabled UI_APPEARANCE_SELECTOR;</span><br><span class="line"></span><br><span class="line">// 进度， 一般网络下载数据时很有效果</span><br><span class="line">@property (assign, nonatomic) float progress;</span><br></pre></td></tr></table></figure></p>
<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>在使用MBProgressHUD时，我们会发现三个构造方法可以使用。在新版本中，废弃了一些方法，替换了新方法。如下所示的三个方法，分别是生成HUD视图，隐藏HUD视图，从父视图查找HUD视图，具体描述如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"> /**</span><br><span class="line"> *</span><br><span class="line"> * 创建一个你的HUD， 添加到并显示到提供的view上。对应的隐藏方法为hideHUDForView:animated:.</span><br><span class="line"> *</span><br><span class="line"> * 注意: 这个方法设置了当隐藏时从父视图移除的属性。</span><br><span class="line"> *</span><br><span class="line"> * @param view: 将在父视图view添加HUD</span><br><span class="line"> * @param animated: 是否显示动画，如果设置YES，即表示即将显示HUD的时候会按照animationType显示，反之则不会显示动画。事实上animationType在初始化的时候，默认为.Fade，在显示的时候并不会根据设定的animationType来显示。</span><br><span class="line"> * </span><br><span class="line"> * @return 根据以上参数显示的HUD</span><br><span class="line"> *</span><br><span class="line"> * @see 与之对应的隐藏参见hideHUDForView:animated:</span><br><span class="line"> * @see 动画显示参见animationType</span><br><span class="line"> */</span><br><span class="line">  + (instancetype)showHUDAddedTo:(UIView *)view animated:(BOOL)animated;</span><br><span class="line">   </span><br><span class="line">/**</span><br><span class="line"> *</span><br><span class="line"> * 寻找view中最顶端的HUD，对应的显示方法为showHUDAddedTo:animated:.</span><br><span class="line"> *</span><br><span class="line"> * 注意：这个方法会自动设置了removeFromSuperViewOnHide，即隐藏时，从父视图移除。</span><br><span class="line"> *</span><br><span class="line"> * @param view表示在传入的view查找是否存在HUD这个子视图</span><br><span class="line"> * @param 当animated = YES时，表示在即将隐藏的时候会根据animationType的动画方式隐藏HUD视图，反之则不需要动画</span><br><span class="line"> * 当HUD消失的时候执行animations动画</span><br><span class="line"> * @return YES代表HUD找到了并且移除了，相反则返回NO</span><br><span class="line"> *</span><br><span class="line"> * @see 对应的生成方法showHUDAddedTo:animated:</span><br><span class="line"> * @see 移除过程中的动画类型</span><br><span class="line"> */</span><br><span class="line"> + (BOOL)hideHUDForView:(UIView *)view animated:(BOOL)animated;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 寻找view上最顶层的HUD视图</span><br><span class="line"> *</span><br><span class="line"> * @param view 即将要查询的父视图</span><br><span class="line"> * @return 发现的最顶层的HUD视图</span><br><span class="line"> */</span><br><span class="line"> + (nullable MBProgressHUD *)HUDForView:(UIView *)view;`</span><br></pre></td></tr></table></figure></p>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>MBProgressHUD所有的初始化方法中，共同的初始化都只有一个函数<strong> - (void)commonInit </strong>。在这个方法里，进行了各类属性的初始化值的设定，以及初始化视图、更新indicators和注册通知。如下所示:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[self setupViews]; // 设置基本view</span><br><span class="line">[self updateIndicators]; // 更新indicators</span><br><span class="line">[self registerForNotifications]; // 注册通知</span><br></pre></td></tr></table></figure></p>
<p>初始化视图和属性，这个没得说，就是我们需要显示视图的各类初始化。那么更新indicators这个方法呢，就是绑定我们我们设置的model方法，并根据model类型，设定HUD所需要显示的样式。注册通知，这个方法注册似的屏幕旋转时，需要改变的大小。</p>
<h3 id="关于新版本"><a href="#关于新版本" class="headerlink" title="关于新版本"></a>关于新版本</h3><p>最新版本0.9.2，相对于0.9.1做了很多调整。包括一些生成方法、属性、布局等，都做了调整。譬如，现在的布局方式采用了auto layout，以前是采用数学计算的方式来完成了，算是一个不小的调整。接着，有人说，当网络请求想消失时，之前的版本是无法做到的。那么在新的版本中，我们可以设置HUD中button的title值，target方法即可完成我们需要的功能了。新版本中废弃的方法，作者也是做出了相应提示。在<strong>MBProgressHUD (Deprecated)</strong>中就可以查看那些方法是被废弃掉了的。</p>
<h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>老实说，写一篇源码剖析还真的不知道如何下手。因为也是第一次写博客吧，导致很多都不知道哪些属于重要的知识点。仅仅是自己觉得重要一些的，会拿出来讲。但反过头来再看，整篇文章是没有很多技术性的问题探讨。还是希望如果有人看到了，能指点迷津。在此谢过……</p>
<p>参考：<a href="http://southpeak.github.io/blog/2015/03/24/sourcecode-mbprogresshud/" target="_blank" rel="external">南峰子的技术博客</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.png"
               alt="ySenIn" />
          <p class="site-author-name" itemprop="name">ySenIn</p>
          <p class="site-description motion-element" itemprop="description">一个孤独的人，一个不想孤独的人</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">14</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">9</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">19</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
  <span id="busuanzi_container_site_pv">pv: <span id="busuanzi_value_site_pv"></span></span>
  <span id="busuanzi_container_site_uv">uv: <span id="busuanzi_value_site_uv"></span></span>
  <span class="author" itemprop="copyrightHolder">ySenIn</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"ysenin"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
  





  
  
  

  

  

</body>
</html>
